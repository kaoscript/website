---
name: Functions
menu: Guide
route: /guide/functions
---

# Functions

|                            | function | anonymous | lambda |
| :------------------------: | :------: | :-------: | :----: |
|       overload-able        |    ✅    |    ❌     |   ❌   |
|         async-able         |    ✅    |    ✅     |   ✅   |
|        return type         |    ✅    |    ✅     |   ✅   |
|        error types         |    ✅    |    ✅     |   ✅   |
|         statement          |    ✅    |    ❌     |   ❌   |
|         expression         |    ❌    |    ✅     |   ✅   |
| accessible parent's `this` |    ❌    |    ❌     |   ✅   |

## function

### Syntax

```syntax
[async] func *varname* '(' [[*parameter1*] [, [*parameter2*] ... [, [*parameterN*]]] ')' [(: *type* | auto)] [~ *class1* [, *class2* ... [, *classN*]]] [( => *expression* | {
	*...statements*
})]
```

### Examples

```kaoscript
import '@zokugun/lang'

func alpha(n: Number, percentage = false): Number {
	var i = n.toInt()

	return 1 if i == NaN else (percentage ? i / 100 : i).limit(0, 1).round(3)
}

func red() => '#FF0000'
```

## anonymous

### Syntax

```syntax
[async] func '(' [[*parameter1*] [, [*parameter2*] ... [, [*parameterN*]]] ')' [: *type*] [~ *class1* [, *class2* ... [, *classN*]]] [( => *expression* | {
	*...statements*
})]
```

### Examples

```kaoscript
foobar(func(a:Number, b:Number) {
	return a - b
})

foobar(func(a:Number, b:Number): Number => a - b)
```

## lambda

### Syntax

```syntax
[async] ( '(' [[*parameter1*] [, [*parameter2*] ... [, [*parameterN*]]] ')' [: *type*] [~ *class1* [, *class2* ... [, *classN*]]] | *parameter* ) => [( *expression* | {
	*...statements*
})]
```

### Examples

```kaoscript
foobar((a:Number, b:Number) => {
	return a - b
})

foobar((a:Number, b:Number): Number => a - b)
```

## parameters

### Syntax

```syntax
parameter = [mut] (
	[(# | \* | ([\*] *varname*) %)] *varname* (
		! [: *param-type*] [?] (= | ??= | ##=) *expression*
		|
		[: *param-type*] [?] [(= | ??= | ##=) *expression*]
	)
	|
	[[\*] *varname* %] _ (
		! [: *param-type*] [?] (= | ??= | ##=) *expression*
		|
		[: *param-type*] [?] [(= | ??= | ##=) *expression*]
	)
	|
	[[\*] *varname* %] *destructuring* (
		! [: *param-type*] [?] (= | ??= | ##=) *expression*
		|
		[: *param-type*] [?] [(= | ??= | ##=) *expression*]
	)
	|
	[*varname* %] ...[{( [*min*], [*max*] | *quantity* )}][*varname*] [: *param-type*] [?] [(= | ##=) *expression*]
)
```

### Examples

```kaoscript
require expect: func

func foo(u = null, v, x, y = null, z = null) {
	return [u, v, x, y, z]
}

expect(() => foo()).to.throw()

expect(() => foo(1)).to.throw()

expect(foo(1, 2)).to.eql([null, 1, 2, null, null])

expect(foo(1, 2, 3)).to.eql([1, 2, 3, null, null])

expect(foo(1, 2, 3, 4)).to.eql([1, 2, 3, 4, null])

expect(foo(1, 2, 3, 4, 5)).to.eql([1, 2, 3, 4, 5])
```

### Distribution

|                               | Required | Nullable | Typed | Default Value |
| ----------------------------- | :------: | :------: | :---: | :-----------: |
| `foo(x)`                      |    ✅    |    ❌    |  ❌   |      ❌       |
| `foo(x?)`                     |    ✅    |    ✅    |  ❌   |      ❌       |
| `foo(x!)`                     |   ☠️   |   ☠️   | ☠️  |     ☠️      |
| `foo(x!?)`                    |   ☠️   |   ☠️   | ☠️  |     ☠️      |
| `foo(x = null)`               |   ☠️   |   ☠️   | ☠️  |     ☠️      |
| `foo(x = 'foobar')`           |    ❌    |    ❌    |  ❌   |      ✅       |
| `foo(x? = null)`              |    ❌    |    ✅    |  ❌   |      ✅       |
| `foo(x? = 'foobar')`          |    ❌    |    ✅    |  ❌   |      ✅       |
| `foo(x! = null)`              |   ☠️   |   ☠️   | ☠️  |     ☠️      |
| `foo(x! = 'foobar')`          |    ✅    |    ❌    |  ❌   |      ✅       |
| `foo(x!? = null)`             |    ✅    |    ✅    |  ❌   |      ✅       |
| `foo(x!? = 'foobar')`         |   ☠️   |   ☠️   | ☠️  |     ☠️      |
| `foo(x: String)`              |    ✅    |    ❌    |  ✅   |      ❌       |
| `foo(x: String?)`             |    ✅    |    ✅    |  ✅   |      ❌       |
| `foo(x: String = null)`       |   ☠️   |   ☠️   | ☠️  |     ☠️      |
| `foo(x: String = 'foobar')`   |    ❌    |    ❌    |  ✅   |      ✅       |
| `foo(x: String? = null)`      |    ❌    |    ✅    |  ✅   |      ✅       |
| `foo(x: String? = 'foobar')`  |    ❌    |    ✅    |  ✅   |      ✅       |
| `foo(x!: String = null)`      |   ☠️   |   ☠️   | ☠️  |     ☠️      |
| `foo(x!: String = 'foobar')`  |    ✅    |    ❌    |  ✅   |      ✅       |
| `foo(x!: String? = null)`     |    ✅    |    ✅    |  ✅   |      ✅       |
| `foo(x!: String? = 'foobar')` |   ☠️   |   ☠️   | ☠️  |     ☠️      |

| `x`                              |   `foo()`    | `foo(null)`  |  `foo('')`   | `foo('xyz')` |   type    |
| :------------------------------- | :----------: | :----------: | :----------: | :----------: | :-------: |
| `foo(x)`                         |     ☠️     |     ☠️     |     `''`     |   `'xyz'`    |   `Any`   |
| `foo(x?)`                        |     ☠️     |    `null`    |     `''`     |   `'xyz'`    |  `Any?`   |
| `foo(x = null)`                  |     ☠️     |     ☠️     |     ☠️     |     ☠️     |   ☠️    |
| `foo(x = 'abc')`                 |   `'abc'`    |   `'abc'`    |     `''`     |   `'xyz'`    |   `Any`   |
| `foo(x = 'abc'|null)`            |     ☠️     |     ☠️     |     ☠️     |     ☠️     |   ☠️    |
| `foo(x ??= null)`                |     ☠️     |     ☠️     |     ☠️     |     ☠️     |   ☠️    |
| `foo(x ??= 'abc')`               |   `'abc'`    |   `'abc'`    |     `''`     |   `'xyz'`    |   `Any`   |
| `foo(x ??= 'abc'|null)`          |     ☠️     |     ☠️     |     ☠️     |     ☠️     |   ☠️    |
| `foo(x ##= null)`                |     ☠️     |     ☠️     |     ☠️     |     ☠️     |   ☠️    |
| `foo(x ##= 'abc')`               |   `'abc'`    |   `'abc'`    |   `'abc'`    |   `'xyz'`    |   `Any`   |
| `foo(x ##= 'abc'|null)`          |     ☠️     |     ☠️     |     ☠️     |     ☠️     |   ☠️    |
| `foo(x? = null)`                 |    `null`    |    `null`    |     `''`     |   `'xyz'`    |  `Any?`   |
| `foo(x? = 'abc')`                |   `'abc'`    |    `null`    |     `''`     |   `'xyz'`    |  `Any?`   |
| `foo(x? = 'abc'|null)`           | `'abc'|null` |    `null`    |     `''`     |   `'xyz'`    |  `Any?`   |
| `foo(x? ??= null)`               |    `null`    |    `null`    |     `''`     |   `'xyz'`    |  `Any?`   |
| `foo(x? ??= 'abc')`              |   `'abc'`    |   `'abc'`    |     `''`     |   `'xyz'`    |  `Any?`   |
| `foo(x? ??= 'abc'|null)`         | `'abc'|null` | `'abc'|null` |     `''`     |   `'xyz'`    |  `Any?`   |
| `foo(x? ##= null)`               |    `null`    |    `null`    |    `null`    |   `'xyz'`    |  `Any?`   |
| `foo(x? ##= 'abc')`              |   `'abc'`    |   `'abc'`    |   `'abc'`    |   `'xyz'`    |  `Any?`   |
| `foo(x? ##= 'abc'|null)`         | `'abc'|null` | `'abc'|null` | `'abc'|null` |   `'xyz'`    |  `Any?`   |
| `foo(x: String)`                 |     ☠️     |     ☠️     |     `''`     |   `'xyz'`    | `String`  |
| `foo(x: String?)`                |     ☠️     |    `null`    |     `''`     |   `'xyz'`    | `String?` |
| `foo(x: String = null)`          |     ☠️     |     ☠️     |     ☠️     |     ☠️     |   ☠️    |
| `foo(x: String = 'abc')`         |   `'abc'`    |   `'abc'`    |     `''`     |   `'xyz'`    | `String`  |
| `foo(x: String = 'abc'|null)`    |     ☠️     |     ☠️     |     ☠️     |     ☠️     |   ☠️    |
| `foo(x: String ??= 'abc')`       |   `'abc'`    |   `'abc'`    |     `''`     |   `'xyz'`    | `String`  |
| `foo(x: String ##= 'abc')`       |   `'abc'`    |   `'abc'`    |   `'abc'`    |   `'xyz'`    | `String`  |
| `foo(x: String? = null)`         |    `null`    |    `null`    |     `''`     |   `'xyz'`    | `String?` |
| `foo(x: String? = 'abc')`        |   `'abc'`    |    `null`    |     `''`     |   `'xyz'`    | `String?` |
| `foo(x: String? = 'abc'|null)`   | `'abc'|null` |    `null`    |     `''`     |   `'xyz'`    | `String?` |
| `foo(x: String? ??= null)`       |    `null`    |    `null`    |     `''`     |   `'xyz'`    | `String?` |
| `foo(x: String? ??= 'abc')`      |   `'abc'`    |   `'abc'`    |     `''`     |   `'xyz'`    | `String?` |
| `foo(x: String? ??= 'abc'|null)` | `'abc'|null` | `'abc'|null` |     `''`     |   `'xyz'`    | `String?` |
| `foo(x: String? ##= null)`       |    `null`    |    `null`    |    `null`    |   `'xyz'`    | `String?` |
| `foo(x: String? ##= 'abc')`      |   `'abc'`    |   `'abc'`    |   `'abc'`    |   `'xyz'`    | `String?` |
| `foo(x: String? ##= 'abc'|null)` | `'abc'|null` | `'abc'|null` | `'abc'|null` |   `'xyz'`    | `String?` |
## named/positional parameter

In `foo(*x) {}`, `*` forces the argument to be passed as a named argument, for example: `foo(x: 42)`.
In `foo(#x) {}`, `#` forces the argument to be passed as a indexed argument. `foo(x: 42)` will throw an error.

|                    | Pass with Index | Pass with Name | External Name | Internal Name |
| ------------------ | :-------------: | :------------: | :-----------: | :-----------: |
| `foo(x) {}`        |       ✅        |       ✅       |      `x`      |      `x`      |
| `foo(*x) {}`       |       ❌        |       ✅       |      `x`      |      `x`      |
| `foo(#x) {}`       |       ✅        |       ❌       |      ❌       |      `x`      |
| `foo(_) {}`        |       ✅        |       ❌       |      ❌       |      ❌       |
| `foo(x % val) {}`  |       ✅        |       ✅       |      `x`      |     `val`     |
| `foo(*x % val) {}` |       ❌        |       ✅       |      `x`      |     `val`     |
| `foo(#x % val) {}` |      ☠️       |      ☠️      |     ☠️      |     ☠️      |
| `foo(x % _) {}`    |       ✅        |       ✅       |      `x`      |      ❌       |
| `foo(*x % _) {}`   |       ❌        |       ✅       |      `x`      |      ❌       |
| `foo(#x % _) {}`   |      ☠️       |      ☠️      |     ☠️      |     ☠️      |
| `foo(_ % val) {}`  |      ☠️       |      ☠️      |     ☠️      |     ☠️      |
| `foo(_ % _) {}`    |      ☠️       |      ☠️      |     ☠️      |     ☠️      |

| `foo(x) {}` | Use Index | Use Name |
| ----------- | :-------: | :------: |
| `foo(0)`    |    ✅     |    ❌    |
| `foo(x)`    |    ✅     |    ✅    |
| `foo(y)`    |    ✅     |    ❌    |
| `foo(x: y)` |    ❌     |    ✅    |
| `foo(:x)`   |    ❌     |    ✅    |
| `foo(\x)`   |    ✅     |    ❌    |

### Examples

```kaoscript
func foobar(mut coord % {x, y}: {x: Number, y: Number} = {x: 0, y: 0}) {}

func foobar(mut *coord % {x, y}!: {x: Number, y: Number} = {x: 0, y: 0}) {}

func foobar(mut *x!: Number = 0) {}

func foobar(mut *x: Number = 0) {}
func foobar(mut #x: Number = 0) {}

func foobar(mut #x!: Number = 0) {}
```

```kaoscript
func placeOrder(*item, *price, *quantity) {}

func powerMod(#x, #y, *mod) {}

func combine(a, b, *validator = () => {}) {}

func check(#x) {}
```

## rest parameter

Unlike JavaScript, in kaoscript, the `rest` parameter is allowed in any position.

### Examples

```kaoscript
func foo(...items) {
	console.log(items)
}

func quux(x = 1, ...items, z = 1) {
	console.log(x, items, z)
}

func corge(...items = [1..5]) {
	console.log(items)
}
```

### Type

The given type of a rest parameter is the type of its elements.

```kaoscript
func foobar(...args: Number) {
	// args is Array<Number>
	for var arg in args {
		// arg is Number
	}
}
```

### Arity

The `rest` parameter can have arity like:

```kaoscript
func foo(...{1,3}args) {
// args will contain between 1 and 3 elements
}

func bar(...{3,}args) {
// args will contain at least 3 elements
}

func quux(...{,3}args) {
// args will contain at most 3 elements
}

func corge(...{3}args) {
// args will contain 3 elements
}
```

## anonymous parameter

In kaoscript, a parameter can be ignored with the placeholder `_` (can be ignored for a rest parameter).

|             | Required | Nullable | Typed | Default Value | No Arg | `null` Arg |
| ----------- | :------: | :------: | :---: | :-----------: | :----: | :--------: |
| `foo(_)`    |    ✅    |    ❌    |  ❌   |      ❌       |  ☠️  |    ☠️    |
| `foo(_?)`   |    ✅    |    ✅    |  ❌   |      ❌       |  ☠️  |   `null`   |
| `foo(...)`  |    ❌    |    ❌    |  ❌   |      ❌       |  `[]`  |    ☠️    |
| `foo(...?)` |    ❌    |    ✅    |  ❌   |      ❌       |  `[]`  |  `[null]`  |

### Examples

```kaoscript
func foo(...) {
}

func bar(_, x, y) {
	console.log(x, y)
}
```

## this parameter

|                                 | function/anonymous() | function/anonymous(this: Type) | lambda() | lambda(this: Type) |
|:-------------------------------:|:--------------------:|:------------------------------:|:--------:|:------------------:|
|        new local `this`         |          ❌          |               ❌               |    ❌    |         ❌         |
| local `this` is parent's `this` |          ❌          |               ❌               |    ✅    |         ❌         |
|        accessible `this`        |          ❌          |               ✅               |    ✅    |         ✅         |
|        accessible parent        |          ❌          |               ❌               |    ✅    |         ❌         |
|        accessible module        |          ✅          |               ✅               |    ✅    |         ✅         |

In a function, the `this` variable is reserved and can only be used if declared like:

```kaoscript
func isCat(this) {
	return this.kind == 'cat'
}

func isDog() {
	return this.kind == 'dog'
	// an error will be thrown at compilation time
}
```

### type

```kaoscript
func isCat(this: Pet) {
	return this.kind == PetKind.Cat
}
```

### lambda

By default, the local `this` of a lambda is an alias of its parent's `this`.
If a `this` parameter is declared, the local `this` will be of that type and so, the parent's `this` won't be accessible.

### callback

```kaoscript
type DB = {
  filterPets(filter: (this: Pet): Boolean): Pet[]
}

func findCats(db: DB): Pet[] {
	return db.filterPets((this) => this.kind == PetKind.Cat)
}
```

### void

A lambda can indicates that it doesn't support `this` by typing it as `Void`.

```kaoscript
type DB = {
  filterPets(filter: (value: Pet): Boolean): Pet[]
}

func findDogs(db: DB): Pet[] {
	var filter = (this: Void, value) => value.kind == PetKind.Dog

	return db.filterPets(filter)
}
```

### rebindable

The `this` scope is rebindable only if it's defined as a parameter and different from `Void`

## asynchronous

`async/await` use the traditional `callback(error, ...values)` where the `error` can be catched with `try/catch`.

### Examples

```kaoscript
import '@zokugun/lang'
import 'child_process' for exec

var df_regex = /([\/[a-z0-9\-\_\s]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+%)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+%)\s+(\/.*)/i

async func disks() {
	var stdout: string, stderr = await exec('df -k')

	var disks = []

	for var line in stdout.lines() {
		if var matches = df_regex.exec(line) {
			disks.push({
				device: matches[1].trim(),
				mount: matches[9],
				total: matches[2].toInt() * 1024,
				used: matches[3].toInt() * 1024,
				available: matches[4].toInt() * 1024
			})
		}
	}

	return disks
}

var d = await disks()
```

## return type

### Syntax

```syntax
: *type*
```

### Examples

```kaoscript
func foobar(): Number => 42
```

### auto

With `auto`, kaoscript will automatically determine the return type

```kaoscript
func foobar(): auto => 42
// return type: Number
```

### void

```kaoscript
func foobar(): void {
}
```

`void` indicates that the function won't ever return any values. So it can never be an operand.
The `void` type can only be used as a return type, it doesn't have any meaning in others contexts.

### never

```kaoscript
func foobar(): never {
	throw Error.new()
}
```

`never` indicates that the function will never return, it will always generate an error.
As for `void`, `never` can only be used as a return type.

The previous code is equivalent to:

```kaoscript
func foobar(): never ~ Error {
	throw Error.new()
}
```

`~ Error` can be omitted since `never` is already indicating that the function will throw an error.

## error handling

Like Java, in kaoscript, a function exposes the list of possible errors. Those errors will have to be handled by the caller. (This behaviour can be disabled with an attribute.)


### Syntax

```syntax
~ *class1* [, *class2* ... [, *classN*]]
```

### Examples

```kaoscript
func foobar() ~ Error {
}

func handled() {
	try {
		foobar()
	}
}

func passed() ~ Error {
	foobar()
}

#[error(off)]
func disabled() {
	foobar()
}

#[error(ignore(Error))]
func filtered() {
	foobar()
}
```

## overloading

kaoscript allows named functions to be overloaded.

### Examples

```kaoscript
func reverse(value: String): String => value.split('').reverse().join('')
func reverse(value: Array): Array => value.slice().reverse()

reverse('foobar')
// 'raboof'

reverse([1, 2, 3, 4])
// [4, 3, 2, 1]
```

## curry (partial, bind)

```kaoscript
func add(x, y) => x + y
func identity(x) => x

// apply from the left:
var addOne = add^^(1, ^)
addOne(2) // 3

// apply from the right:
var addTen = add^^(^, 10)
addTen(2) // 12

// accept a fixed argument list:
var numbers = ['1', '2', '3'].map(parseInt^^(^, 10)) // [1, 2, 3]

// specify ordinal placeholder arguments:
var indices = [1, 2, 3].map(identity^^(^1)) // [0, 1, 2]

// bind `console` as receiver and accepts exactly one argument:
[1, 2, 3].forEach(echo^^(^))
// prints:
// 1
// 2
// 3

func printABC(a = 'arg0', b = 'arg1', c = 'arg2') {
	echo(`\(a), \(b), \(c)`)
}

var printCAA = printABC^^(^2, ^, ^0)
printCAA(1, 2, 3)
// prints:
// 3, 1, 1
printCAA(1, 2)
// prints
// arg0, 1, 1

var printCAA2 = printABC^^(a: ^2, b: ^, c: ^0)

func writeLog(header, ...args) => echo(header, ...args)

var writeAppLog = writeLog^^('[app]', ...)
writeAppLog('Hello', 'World!')
// prints:
// [app] Hello World!

var writeAppLogWithBreak = writeAppLog^^(..., '\n---')
writeAppLogWithBreak('End of section')
// prints:
// [app] End of section
// ---
```

### binding

|      | description  |
| :--: | :----------: |
| `^^` |    curry     |
| `^$` | bind & curry |
| `*$` | bind & call  |

```kaoscript
func sum(this: Number[], ...args: Number): Number {
	return this.reduce((a, b) => a + b, 0) + args.reduce((a, b) => a + b, 0)
}

echo(sum*$([1, 2, 3], 4, 5, 6))
// prints:
// 21

var sum123 = sum^$([1, 2, 3], ...)

echo(sum123(4, 5, 6))
// prints:
// 21
```

## retained parameters

By default, kaoscript generates functions without the list of parameters.
But, if you need, you can use either:

```kaoscript
describe('#save()', () => {
	it('should save without error', (#[retain] done) => {
		var user = User.new('Luna')
		var res, err = await user.save()

		done(err)
	})
})
```
or
```kaoscript
#![retain-parameters]

describe('#save()', () => {
	it('should save without error', (done) => {
		var user = User.new('Luna')
		var res, err = await user.save()

		done(err)
	})
})
```
or
```kaoscript
extern {
	func describe(title: String, fn: (): Void): Void
	func it(title: string, fn: (#[retain] done: Function): Void): Void
}

describe('#save()', () => {
	it('should save without error', (done) => {
		var user = User.new('Luna')
		var res, err = await user.save()

		done(err)
	})
})
```
