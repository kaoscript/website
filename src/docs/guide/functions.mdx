---
name: Functions
menu: Guide
route: /guide/functions
---

# Functions

In kaoscript, there is three types of functions:
- named functions
- anonymous functions
- arrow functions

|                                 | named function | anonymous function | arrow function |
| :-----------------------------: | :------------: | :----------------: | :------------: |
|        new local `this`         |       ✅       |         ✅         |       ❌       |
| local `this` is parent's `this` |       ❌       |         ❌         |       ✅       |
|    access module's variables    |       ✅       |         ✅         |       ✅       |
|    access parent's variables    |       ❌       |         ❌         |       ✅       |
|          overload-able          |       ✅       |         ❌         |       ❌       |
|           async-able            |       ✅       |         ✅         |       ✅       |
|           return type           |       ✅       |         ✅         |       ✅       |
|           error types           |       ✅       |         ✅         |       ✅       |
|            statement            |       ✅       |         ❌         |       ❌       |
|           expression            |       ❌       |         ✅         |       ✅       |

## named function

### Syntax

```syntax
[async] func *varname* '(' [[*parameter1*] [, [*parameter2*] ... [, [*parameterN*]]] ')' [(: *type* | auto)] [~ *class1* [, *class2* ... [, *classN*]]] [( => *expression* | {
	*...statements*
})]
```

### Examples

```kaoscript
import '@zokugun/lang'

func alpha(n: Number, percentage = false): Number {
	var i = n.toInt()

	return 1 if i == NaN else (percentage ? i / 100 : i).limit(0, 1).round(3)
}

func red() => '#FF0000'
```

## anonymous function

### Syntax

```syntax
[async] func '(' [[*parameter1*] [, [*parameter2*] ... [, [*parameterN*]]] ')' [: *type*] [~ *class1* [, *class2* ... [, *classN*]]] [( => *expression* | {
	*...statements*
})]
```

### Examples

```kaoscript
foobar(func(a:Number, b:Number) {
	return a - b
})

foobar(func(a:Number, b:Number): Number => a - b)
```

## arrow function

### Syntax

```syntax
[async] ( '(' [[*parameter1*] [, [*parameter2*] ... [, [*parameterN*]]] ')' [: *type*] [~ *class1* [, *class2* ... [, *classN*]]] | *parameter* ) => [( *expression* | {
	*...statements*
})]
```

### Examples

```kaoscript
var foo = (a:Number, b:Number) => a - b

var four = (a => a / 10)(42)
```

## parameters

### Syntax

```syntax
[mut] (
	[(# | \* | ([\*] *varname* | \_) %)] *varname* (
		! [: *type*] [?] (= | ??= | ##=) *expression*
		|
		[: *type*] [?] [(= | ??= | ##=) *expression*]
	)
	|
	[[\*] *varname* | \_) %] _ (
		! [: *type*] [?] (= | ??= | ##=) *expression*
		|
		[: *type*] [?] [(= | ??= | ##=) *expression*]
	)
	|
	[[\*] *varname* | \_) %] *destructuring* (
		! [: *type*] [?] (= | ??= | ##=) *expression*
		|
		[: *type*] [?] [(= | ??= | ##=) *expression*]
	)
	|
	[(*varname* | \_) %] ...[{( [*min*], [*max*] | *quantity* )}][*varname*] [: *type*] [?] [(= | ##=) *expression*]
)
```

### Examples

```kaoscript
require expect: func

func foo(u = null, v, x, y = null, z = null) {
	return [u, v, x, y, z]
}

expect(() => foo()).to.throw()

expect(() => foo(1)).to.throw()

expect(foo(1, 2)).to.eql([null, 1, 2, null, null])

expect(foo(1, 2, 3)).to.eql([1, 2, 3, null, null])

expect(foo(1, 2, 3, 4)).to.eql([1, 2, 3, 4, null])

expect(foo(1, 2, 3, 4, 5)).to.eql([1, 2, 3, 4, 5])
```

### Distribution

|                               | Required | Nullable | Typed | Default Value |
| ----------------------------- | :------: | :------: | :---: | :-----------: |
| `foo(x)`                      |    ✅    |    ❌    |  ❌   |      ❌       |
| `foo(x?)`                     |    ✅    |    ✅    |  ❌   |      ❌       |
| `foo(x = null)`               |   ☠️   |   ☠️   | ☠️  |     ☠️      |
| `foo(x = 'foobar')`           |    ❌    |    ❌    |  ❌   |      ✅       |
| `foo(x? = null)`              |    ❌    |    ✅    |  ❌   |      ✅       |
| `foo(x? = 'foobar')`          |    ❌    |    ✅    |  ❌   |      ✅       |
| `foo(x! = null)`              |   ☠️   |   ☠️   | ☠️  |     ☠️      |
| `foo(x! = 'foobar')`          |    ✅    |    ❌    |  ❌   |      ✅       |
| `foo(x!? = null)`             |    ✅    |    ✅    |  ❌   |      ✅       |
| `foo(x!? = 'foobar')`         |   ☠️   |   ☠️   | ☠️  |     ☠️      |
| `foo(x: String)`              |    ✅    |    ❌    |  ✅   |      ❌       |
| `foo(x: String?)`             |    ✅    |    ✅    |  ✅   |      ❌       |
| `foo(x: String = null)`       |   ☠️   |   ☠️   | ☠️  |     ☠️      |
| `foo(x: String = 'foobar')`   |    ❌    |    ❌    |  ✅   |      ✅       |
| `foo(x: String? = null)`      |    ❌    |    ✅    |  ✅   |      ✅       |
| `foo(x: String? = 'foobar')`  |    ❌    |    ✅    |  ✅   |      ✅       |
| `foo(x!: String = null)`      |   ☠️   |   ☠️   | ☠️  |     ☠️      |
| `foo(x!: String = 'foobar')`  |    ✅    |    ❌    |  ✅   |      ✅       |
| `foo(x!: String? = null)`     |    ✅    |    ✅    |  ✅   |      ✅       |
| `foo(x!: String? = 'foobar')` |   ☠️   |   ☠️   | ☠️  |     ☠️      |

| `x`                              |   `foo()`    | `foo(null)`  |  `foo('')`   | `foo('xyz')` |   type    |
| :------------------------------- | :----------: | :----------: | :----------: | :----------: | :-------: |
| `foo(x)`                         |     ☠️     |     ☠️     |     `''`     |   `'xyz'`    |   `Any`   |
| `foo(x?)`                        |     ☠️     |    `null`    |     `''`     |   `'xyz'`    |  `Any?`   |
| `foo(x = null)`                  |     ☠️     |     ☠️     |     ☠️     |     ☠️     |   ☠️    |
| `foo(x = 'abc')`                 |   `'abc'`    |   `'abc'`    |     `''`     |   `'xyz'`    |   `Any`   |
| `foo(x = 'abc'|null)`            |     ☠️     |     ☠️     |     ☠️     |     ☠️     |   ☠️    |
| `foo(x ??= null)`                |     ☠️     |     ☠️     |     ☠️     |     ☠️     |   ☠️    |
| `foo(x ??= 'abc')`               |   `'abc'`    |   `'abc'`    |     `''`     |   `'xyz'`    |   `Any`   |
| `foo(x ??= 'abc'|null)`          |     ☠️     |     ☠️     |     ☠️     |     ☠️     |   ☠️    |
| `foo(x ##= null)`                |     ☠️     |     ☠️     |     ☠️     |     ☠️     |   ☠️    |
| `foo(x ##= 'abc')`               |   `'abc'`    |   `'abc'`    |   `'abc'`    |   `'xyz'`    |   `Any`   |
| `foo(x ##= 'abc'|null)`          |     ☠️     |     ☠️     |     ☠️     |     ☠️     |   ☠️    |
| `foo(x? = null)`                 |    `null`    |    `null`    |     `''`     |   `'xyz'`    |  `Any?`   |
| `foo(x? = 'abc')`                |   `'abc'`    |    `null`    |     `''`     |   `'xyz'`    |  `Any?`   |
| `foo(x? = 'abc'|null)`           | `'abc'|null` |    `null`    |     `''`     |   `'xyz'`    |  `Any?`   |
| `foo(x? ??= null)`               |    `null`    |    `null`    |     `''`     |   `'xyz'`    |  `Any?`   |
| `foo(x? ??= 'abc')`              |   `'abc'`    |   `'abc'`    |     `''`     |   `'xyz'`    |  `Any?`   |
| `foo(x? ??= 'abc'|null)`         | `'abc'|null` | `'abc'|null` |     `''`     |   `'xyz'`    |  `Any?`   |
| `foo(x? ##= null)`               |    `null`    |    `null`    |    `null`    |   `'xyz'`    |  `Any?`   |
| `foo(x? ##= 'abc')`              |   `'abc'`    |   `'abc'`    |   `'abc'`    |   `'xyz'`    |  `Any?`   |
| `foo(x? ##= 'abc'|null)`         | `'abc'|null` | `'abc'|null` | `'abc'|null` |   `'xyz'`    |  `Any?`   |
| `foo(x: String)`                 |     ☠️     |     ☠️     |     `''`     |   `'xyz'`    | `String`  |
| `foo(x: String?)`                |     ☠️     |    `null`    |     `''`     |   `'xyz'`    | `String?` |
| `foo(x: String = null)`          |     ☠️     |     ☠️     |     ☠️     |     ☠️     |   ☠️    |
| `foo(x: String = 'abc')`         |   `'abc'`    |   `'abc'`    |     `''`     |   `'xyz'`    | `String`  |
| `foo(x: String = 'abc'|null)`    |     ☠️     |     ☠️     |     ☠️     |     ☠️     |   ☠️    |
| `foo(x: String ??= 'abc')`       |   `'abc'`    |   `'abc'`    |     `''`     |   `'xyz'`    | `String`  |
| `foo(x: String ##= 'abc')`       |   `'abc'`    |   `'abc'`    |   `'abc'`    |   `'xyz'`    | `String`  |
| `foo(x: String? = null)`         |    `null`    |    `null`    |     `''`     |   `'xyz'`    | `String?` |
| `foo(x: String? = 'abc')`        |   `'abc'`    |    `null`    |     `''`     |   `'xyz'`    | `String?` |
| `foo(x: String? = 'abc'|null)`   | `'abc'|null` |    `null`    |     `''`     |   `'xyz'`    | `String?` |
| `foo(x: String? ??= null)`       |    `null`    |    `null`    |     `''`     |   `'xyz'`    | `String?` |
| `foo(x: String? ??= 'abc')`      |   `'abc'`    |   `'abc'`    |     `''`     |   `'xyz'`    | `String?` |
| `foo(x: String? ??= 'abc'|null)` | `'abc'|null` | `'abc'|null` |     `''`     |   `'xyz'`    | `String?` |
| `foo(x: String? ##= null)`       |    `null`    |    `null`    |    `null`    |   `'xyz'`    | `String?` |
| `foo(x: String? ##= 'abc')`      |   `'abc'`    |   `'abc'`    |   `'abc'`    |   `'xyz'`    | `String?` |
| `foo(x: String? ##= 'abc'|null)` | `'abc'|null` | `'abc'|null` | `'abc'|null` |   `'xyz'`    | `String?` |
## named/positional parameter

In `foo(*x) {}`, `*` forces the argument to be passed as a named argument, for example: `foo(x: 42)`.
In `foo(#x) {}`, `#` forces the argument to be passed as a indexed argument. `foo(x: 42)` will throw an error.

|                    | Pass with Index | Pass with Name | External Name | Internal Name |
| ------------------ | :-------------: | :------------: | :-----------: | :-----------: |
| `foo(x) {}`        |       ✅        |       ✅       |      `x`      |      `x`      |
| `foo(*x) {}`       |       ❌        |       ✅       |      `x`      |      `x`      |
| `foo(#x) {}`       |       ✅        |       ❌       |      ❌       |      `x`      |
| `foo(_) {}`        |       ✅        |       ❌       |      ❌       |      ❌       |
| `foo(x % val) {}`  |       ✅        |       ✅       |      `x`      |     `val`     |
| `foo(*x % val) {}` |       ❌        |       ✅       |      `x`      |     `val`     |
| `foo(#x % val) {}` |      ☠️       |      ☠️      |     ☠️      |     ☠️      |
| `foo(_ % val) {}`  |       ✅        |       ❌       |      ❌       |     `val`     |
| `foo(_ % _) {}`    |       ✅        |       ❌       |      ❌       |      ❌       |
| `foo(x % _) {}`    |       ✅        |       ✅       |      `x`      |      ❌       |
| `foo(*x % _) {}`   |       ❌        |       ✅       |      `x`      |      ❌       |
| `foo(#x % _) {}`   |      ☠️       |      ☠️      |     ☠️      |     ☠️      |

| `foo(x) {}` | Use Index | Use Name |
| ----------- | :-------: | :------: |
| `foo(0)`    |    ✅     |    ❌    |
| `foo(x)`    |    ✅     |    ✅    |
| `foo(y)`    |    ✅     |    ❌    |
| `foo(x: y)` |    ❌     |    ✅    |
| `foo(:x)`   |    ❌     |    ✅    |

### Examples

```kaoscript
func foobar(mut coord % {x, y}: {x: Number, y: Number} = {x: 0, y: 0}) {}

func foobar(mut *coord % {x, y}!: {x: Number, y: Number} = {x: 0, y: 0}) {}

func foobar(mut *x!: Number = 0) {}

func foobar(mut *x: Number = 0) {}
func foobar(mut #x: Number = 0) {}

func foobar(mut &x!: Number = 0) {}
func foobar(mut #x!: Number = 0) {}
```

```kaoscript
func placeOrder(*item, *price, *quantity) {}

func powerMod(#x, #y, *mod) {}

func combine(a, b, *validator = () => {}) {}

func check(#x) {}
```

## rest parameter

Unlike JavaScript, in kaoscript, the `rest` parameter is allowed in any position.

### Examples

```kaoscript
func foo(...items) {
	console.log(items)
}

func quux(x = 1, ...items, z = 1) {
	console.log(x, items, z)
}

func corge(...items = [1..5]) {
	console.log(items)
}
```

### Type

The given type of a rest parameter is the type of its elements.

```kaoscript
func foobar(...args: Number) {
	// args is Array<Number>
	for var arg in args {
		// arg is Number
	}
}
```

### Arity

The `rest` parameter can have arity like:

```kaoscript
func foo(...{1,3}args) {
// args will contain between 1 and 3 elements
}

func bar(...{3,}args) {
// args will contain at least 3 elements
}

func quux(...{,3}args) {
// args will contain at most 3 elements
}

func corge(...{3}args) {
// args will contain 3 elements
}
```

## anonymous parameter

In kaoscript, a parameter can be ignored with the placeholder `_` (can be ignored for a rest parameter).

|             | Required | Nullable | Typed | Default Value | No Arg | `null` Arg |
| ----------- | :------: | :------: | :---: | :-----------: | :----: | :--------: |
| `foo(_)`    |    ✅    |    ❌    |  ❌   |      ❌       |  ☠️  |    ☠️    |
| `foo(_?)`   |    ✅    |    ✅    |  ❌   |      ❌       |  ☠️  |   `null`   |
| `foo(...)`  |    ❌    |    ❌    |  ❌   |      ❌       |  `[]`  |    ☠️    |
| `foo(...?)` |    ❌    |    ✅    |  ❌   |      ❌       |  `[]`  |  `[null]`  |

### Examples

```kaoscript
func foo(...) {
}

func bar(_, x, y) {
	console.log(x, y)
}
```

## asynchronous

`async/await` use the traditional `callback(error, ...values)` where the `error` can be catched with `try/catch`.

### Examples

```kaoscript
import '@zokugun/lang'
import 'child_process' for exec

var df_regex = /([\/[a-z0-9\-\_\s]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+%)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+%)\s+(\/.*)/i

async func disks() {
	var stdout: string, stderr = await exec('df -k')

	var disks = []

	for var line in stdout.lines() {
		if var matches = df_regex.exec(line) {
			disks.push({
				device: matches[1].trim(),
				mount: matches[9],
				total: matches[2].toInt() * 1024,
				used: matches[3].toInt() * 1024,
				available: matches[4].toInt() * 1024
			})
		}
	}

	return disks
}

var d = await disks()
```

## return type

### Syntax

```syntax
: *type*
```

### Examples

```kaoscript
func foobar(): Number => 42
```

### auto

With `auto`, kasocript will automatically determine the return type

```kaoscript
func foobar(): auto => 42
// return type: Number
```

### void

```kaoscript
func foobar(): void {
}
```

`void` indicates that the function won't ever return any values. So it can never be an operand.
The `void` type can only be used as a return type, it doesn't have any meaning in others contexts.

### never

```kaoscript
func foobar(): never {
	throw new Error()
}
```

`never` indicates that the function will never return, it will always generate an error.
As for `void`, `never` can only be used as a return type.

The previous code is equivalent to:

```kaoscript
func foobar(): never ~ Error {
	throw new Error()
}
```

`~ Error` can be omitted since `never` is already indicating that the function will throw an error.

## error handling

Like Java, in kaoscript, a function exposes the list of possible errors. Those errors will have to be handled by the caller. (This behaviour can be disabled with an attribute.)


### Syntax

```syntax
~ *class1* [, *class2* ... [, *classN*]]
```

### Examples

```kaoscript
func foobar() ~ Error {
}

func handled() {
	try {
		foobar()
	}
}

func passed() ~ Error {
	foobar()
}

#[error(off)]
func disabled() {
	foobar()
}

#[error(ignore(Error))]
func filtered() {
	foobar()
}
```

## overloading

kaoscript allows named functions to be overloaded.

### Examples

```kaoscript
func reverse(value: String): String => value.split('').reverse().join('')
func reverse(value: Array): Array => value.slice().reverse()

reverse('foobar')
// 'raboof'

reverse([1, 2, 3, 4])
// [4, 3, 2, 1]
```

## currying

|      |     `this` is     |
|:----:|:-----------------:|
| `^$` |  first argument   |
| `^^` |      `null`       |
| `^@` | function's `this` |

### argument

```kaoscript
var log = console.log^$(console, 'hello:')

log('foo')
// hello: foo
```

### null

```kaoscript
func log(...args) {
	console.log(...args)
}

var logHello = log^^('hello:')

logHello('foo')
// hello: foo
```

### self

```kaoscript
var log = console.log^@('hello:')

log('foo')
// hello: foo
```

## calling

|      |     `this` is     |
|:----:|:-----------------:|
| `*$` |  first argument   |
| `**` |      `null`       |

### argument

```kaoscript
func log(...args) {
	this.log(...args)
}

log*$(console, 'hello')
```

### null

```kaoscript
func log(...args) {
	console.log(...args)
}

log**('hello')
```

## preserved parameters

By default, kaoscript generates functions without the list of parameters.
But, if you need, you can use either:

```kaoscript
describe('', () => {
	it('', (#[preserve] done) => {
		done()
	})
})
```
or
```kaoscript
#![preserve-parameters]

describe('#save()', () => {
	it('should save without error', (done) => {
		var user = new User('Luna')
		var res, err = await user.save()

		done(err)
	})
})
```
