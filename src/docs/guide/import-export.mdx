---
name: Import & Export
menu: Guide
route: /guide/import-export
---

# Import & Export

## import

`import` is used to import bindings which are exported by another module.

### examples

```kaoscript
import 'chai' for expect
// functions: expect

import 'foobar.ks' for name => foo
// variables: foo

import 'quxbaz.ks'(foo)
// all properties
```

```kaoscript
import 'color.ks' for Color => C, Space => S
// variables: C, S

import 'color.srgb.ks'(Color: C, Space: S) for {
	Color => C
	Space => S
}
// variables: C, S

import 'color.ks'
// variables: Color, Space, ...

import 'color.js'
// variable: color (type is unknown)
```

```kaoscript
import 'parser.js' {
	func createToken
	sealed class Lexer
	sealed class Parser
	sealed class Token
}
// namespace: parser
// functions: parser.createToken
// classes: parser.Lexer, parser.Parser, parser.Token

import 'parser.js' for {
	func createToken
	sealed class Lexer
	sealed class Parser
	sealed class Token
}
// functions: createToken
// classes: Lexer, Parser, Token

import 'parser.js' {
	func createToken
	sealed class Lexer
	sealed class Parser
	sealed class Token
} => CT
// namespace: CT
// functions: CT.createToken
// classes: CT.Lexer, CT.Parser, CT.Token
```

```kaoscript
import 'chai' {
	type ChaiUtils = Any
	type ChaiPlugin = (chai: ChaiStatic, utils: ChaiUtils): Void
	type Config = {
		includeStack: Boolean
		showDiff: Boolean
		truncateThreshold: Number
		useProxy: Boolean
		proxyExcludedKeys: String[]
	}

	type ChaiStatic {
		var util: ChaiUtils
		var config: Config

		func expect(value: Any?, message: String = ''): Any
		func use(fn: ChaiPlugin): ChaiStatic
	}

	var chai: ChaiStatic

	export = chai
} => chai, { expect }
```

### unnamed JavaScript module

Unnamed import will generate a *variable* whose name will based on the module name.

```kaoscript
import 'node:fs'
// variable: fs

import 'klaw-sync'
// variable: klawSync
```

### parameters

When importing a kaoscript module, this module might require some parameters (defined with the statement `require`).

Those parameters are given like:

```kaoscript
class Color {
}

class Space {
}

import 'color.srgb'(Color, Space)
```

It's supporting named parameters, so you can do:

```kaoscript
class MyColor {
}

class MySpace {
}

import 'color.srgb'(Color: MyColor, Space: MySpace)
```

If any parameter is missing or doesn't match, kaoscript will throw an error.

### require modifier

`require` is a modifier for import parameter.

```kaoscript
import 'moduleX'(require ClassY)
```

kaoscript will *require* the class `ClassY` with the same type as expected by the module `moduleX`.

### autofill parameters

```kaoscript
import '@zokugun/lang'
import '@zokugun/lang.color'(...)
```

`(...)` indicates to kaoscript that it needs to find the matching parameters from availables variables.

### limitation on file resolution

To avoid any possible dependency injection due to automatic file resolution, the following features are enabled:
- **mandatory file extensions**: to resolve relative or absolute paths, the file extension must be provided (`import './type.ks'`)
- **no directory discovery**: the directory index must also be provided (`import './utils/index.ks'`)

### node modules

Node modules need to use the scheme `node:` (`import 'node:fs'`).

### syntax

```syntax
 import (
	{
		*import-declarator*+
	}
	|
	*import-declarator*
)

import-declarator = "*path*" ['(' *parameter1*, ..., *parameterN* ')' | '(...)'] [(
	for (
		*varname1* [=> *newname1*], ..., *varnameN* [=> *newnameN*]
		|
		*descriptive-type* [=> *newname1*, ..., *newnameN*]
		|
		{
			(*descriptive-type* [=> *newname1*, ..., *newnameN*)+
		}
	)
	|
	but (
		*varname1*, ..., *varnameN*
		|
		{
			(*varname*)+
		}
	)
	|
	{
		(*descriptive-type*)+

		[export (
			*varname1*, ..., *varnameN*
			|
			{
				(*varname*)+
			}
			|
			= *varname*
		)]
	} [
		=> *newname1*, ..., *newnameN*
		|
		for (
			'\*'
			|
			*varname1* [=> *newname1*], ..., *varnameN* [=> *newnameN*]
			|
			{
				(*varname* [=> *newname*])+
			}
		)
	]
	|
	=> *newname1*, ..., *newnameN*
)]

newname = *varname* | *destructuring*
```

## export

`export` is used when creating modules to export functions, objects, or primitive values from the module so they can be used by other programs with the `import` statement.

### examples

```kaoscript
var PI = 3.14

export PI
```

```kaoscript
export enum Space<String> {
	RGB
	SRGB
}
```

```kaoscript
namespace NS {
	export {
		func foo() {
		}

		func bar() {
		}

		func qux() {
		}
	}
}
export NS for foo, bar, qux
```

### syntax

```syntax
 export (
	\* [but (
		*varname1*, ..., *varnameN*
		|
		{
			(*varname*)+
		}
	)]
	|
	{
		*export-declarator*+
	}
	|
	*export-declarator*
)

export-declarator = (
	*statement*
	|
	*varname* [(
		'.\*'
		|
		=> *varname*
		|
		for (
			'\*'
			|
			{
				(*varname* [=> *alias*][,])+
			}
			|
			*varname1* [=> *alias1*], ..., *varnameN* [=> *aliasN*]
		)
	)]
	|
	*import-declarator*
)
```
