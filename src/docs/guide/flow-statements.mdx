---
name: Flow Statements
menu: Guide
route: /guide/flow-statements
---

# Flow Statements

> Any tests require a boolean.

If the test can't be a boolean, an error will thrown at compilation time.
If the type is unknow, the test's value must be equal to `true`.

## if...else

### Syntax

```syntax
if
	*expression:Boolean*
	|
	var [mut] (*varname* | *destructuring*) [: *type*] (?= | #=) *expression* [;; *expression:Boolean*]
{
	*...statements*
}
(else if
	*expression:Boolean*
	|
	var [mut] (*varname* | *destructuring*) [: *type*] (?= | #=) *expression* [;; *expression:Boolean*]
{
	*...statements*
})\*
[else {
	*...statements*
}]
```

### Examples

```kaoscript
if x == 5 {
}
else if var x ?= getX() {
	// x is:
	// - immutable
	// - not null
}
else {
}
```

## unless

`unless x` is equivalent to `if !x`.

### Syntax

```syntax
unless *expression:Boolean* {
	*...statements*
}
```

### Examples

```kaoscript
unless x == 0 {
}
```

## for...from

### Syntax

```syntax
for
	[var [mut]] *varname*
	from[~] *expression:Number*
	[(down | up)]
	[to[~] *expression:Number*]
	[step *expression:Number*]
	[(while | until) *expression:Boolean*]
	[when *expression:Boolean*]
{
	*...statements*
}
[else {
	...*statements*
}]
```

### Examples

```kaoscript
for var x from 0 to 10 {
	console.log(x)
}
// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10

for var x from 0 to~ 10 {
	console.log(x)
}
// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9

for var x from~ 0 to~ 10 {
	console.log(x)
}
// 1, 2, 3, 4, 5, 6, 7, 8, 9
```

### Down/Up

If `down` or `up`, the expressions for `from`, `to` and `step` are asserted.
If `step` is provider, it must be positive for either `up` or `down`.

### Else

The `else` branch is called when the body of the loop has never been called.

## for...in

Unlike JavaScript, in kaoscript, `for...in` loops an array.

### Syntax

```syntax
for
	[var [ mut | dyn ]] (*varname* | *destructuring* | '_') [: *type*] [, *index*]
	in *expression:Array*
	[from[~] *expression:Number*]
	[(down | up)]
	[to[~] *expression:Number*]
	[step *expression:Number*]
	[split *expression:Number*]
	[(while | until) *expression:Boolean*]
	[when *expression:Boolean*]
{
	*...statements*
}
[else {
	...*statements*
}]
```

### Examples

```kaoscript
var heroes = ['leto', 'duncan', 'goku']

for var hero, index in heroes when index % 2 == 0 {
	console.log(hero)
}
// leto, goku
```

```kaoscript
var heroes = ['leto', 'duncan', 'goku']

for var hero in heroes until hero == 'duncan' {
	console.log(hero)
}
// leto
```

### From/To

- `from x to y` <=> `from x to y step 1` <=> `from x up to y` :=> from left ot right
- `from x to y step -1` <=> `from x down to y` :=> from right to left

```kaoscript
var heroes = ['leto', 'duncan', 'goku', 'batman', 'asterix', 'naruto', 'totoro']

for var hero in heroes {
	console.log(hero)
}
// leto, duncan, goku, batman, asterix, naruto, totoro
```

| from      | to      | step      | result                                                |
| --------- | ------- | --------- | ----------------------------------------------------- |
| `from 0`  | `to 6`  | `step 1`  | *leto, duncan, goku, batman, asterix, naruto, totoro* |
| `from 6`  | `to 0`  | `step 1`  |                                                       |
| `from 0`  | `to -1` | `step 1`  | *leto, duncan, goku, batman, asterix, naruto, totoro* |
| `from -1` | `to 0`  | `step 1`  |                                                       |
| `from -3` | `to -1` | `step 1`  | *asterix, naruto, totoro*                             |
| `from -1` | `to -3` | `step 1`  |                                                       |
| `from -3` | `to 6`  | `step 1`  | *asterix, naruto, totoro*                             |
| `from 6`  | `to -3` | `step 1`  |                                                       |
| `from 0`  | `to 6`  | `step -1` |                                                       |
| `from 6`  | `to 0`  | `step -1` | *totoro, naruto, asterix, batman, goku, duncan, leto* |
| `from 0`  | `to -1` | `step -1` |                                                       |
| `from -1` | `to 0`  | `step -1` | *totoro, naruto, asterix, batman, goku, duncan, leto* |
| `from -3` | `to -1` | `step -1` |                                                       |
| `from -1` | `to -3` | `step -1` | *totoro, naruto, asterix*                             |
| `from -3` | `to 6`  | `step -1` |                                                       |
| `from 6`  | `to -3` | `step -1` | *totoro, naruto, asterix*                             |

### Split

```kaoscript
var heroes = [0, 'leto', 1, 'duncan', 2, 'goku']

for var [index, name], i in heroes split 2 {
	console.log(name, index)
}
```

### Else

The `else` branch is called when the given array is **empty** or no value passes the `when` filter.

## for...of

Unlike JavaScript, in kaoscript, `for...in` loops an object.

### Syntax

```syntax
for
	[var [mut]] (*varname* | *destructuring* | '_') [: *type*] [, *key*]
	of *expression:Object*
	[(while | until) *expression:Boolean*]
	[when *expression:Boolean*]
{
	*...statements*
}
[else {
	...*statements*
}]
```

### Examples

```kaoscript
likes = {
	leto: 'spice'
	paul: 'chani'
	duncan: 'murbella'
}

for value, key of likes {
	console.log(`\(key) likes \(value)`)
}
// leto likes spice
// paul likes chani
// duncan likes murbella
```

### Else

The `else` branch is called when the given object is **empty** or no value passes the `when` filter.

## for...range

### Syntax

```syntax
for
	[var [mut]] (*varname* | '_') [, *index*]
	in *operand:Number*[<]..[<]*operand:Number*[..*operand:Number*]
	[(while | until) *expression:Boolean*]
	[when *expression:Boolean*]
{
	*...statements*
}
```

### Examples

```kaoscript
for x in 0..10..2 while test(x) {
}
```

## multi-lines if

### Examples

```kaoscript
if {
	var values ?= loadValues() ;; value.hasValues()
	var value ?= values.getTop()
}
then {
	echo(value)
}
```

### Syntax

```syntax
if {
	(var [mut] (*varname* | *destructuring*) [: *type*] (?= | #=) *expression* [;; *expression:Boolean*])+
}
then {
	*...statements*
}
(else if {
	(var [mut] (*varname* | *destructuring*) [: *type*] (?= | #=) *expression* [;; *expression:Boolean*])+
}
then {
	*...statements*
})\*
[else {
	*...statements*
}]
```


## multi-lines for

### Examples

```kaoscript
for {
  var suit in suits
  var rank in ranks
}
then {
  echo(suit, rank)
}
```

### Syntax

```syntax
for {
	(
		var [mut] *varname*
		from[~] *expression:Number*
		[(down | up)]
		[to[~] *expression:Number*]
		[step *expression:Number*]
		[(while | until) *expression:Boolean*]
		[when *expression:Boolean*]
		|
		var [ mut | dyn ] (*varname* | *destructuring* | '\_') [: *type*] [, *index*]
		in *expression:Array*
		[from[~] *expression:Number*]
		[(down | up)]
		[to[~] *expression:Number*]
		[step *expression:Number*]
		[split *expression:Number*]
		[(while | until) *expression:Boolean*]
		[when *expression:Boolean*]
		|
		var [mut] (*varname* | *destructuring* | '\_') [: *type*] [, *key*]
		of *expression:Object*
		[(while | until) *expression:Boolean*]
		[when *expression:Boolean*]
		|
		var [mut] (*varname* | '\_') [, *index*]
		in *operand:Number*[<]..[<]*operand:Number*[..*operand:Number*]
		[(while | until) *expression:Boolean*]
		[when *expression:Boolean*]
	)+
}
then
{
	*...statements*
}
[else {
	...*statements*
}]
```

## while & do...while

`while` executes the loop while the condition is `true`.

### Syntax

```syntax
while
	*expression:Boolean*
	|
	var [mut] (*varname* | *destructuring*) [: *type*] (?= | #=) *expression*
{

}
```

```syntax
do {

}
while *expression:Boolean*
```

### Examples

```kaoscript
while supply > demand {
	buy()
}
```

```kaoscript
do {
	buy()
}
while supply > demand
```

## until & do...until

`until` executes the loop and stops it when the condition becomes `true`.

### Syntax

```syntax
until *expression:Boolean* {

}
```

```syntax
do  {

}
until *expression:Boolean*
```

### Examples

```kaoscript
until supply > demand {
	sell()
}
```

```kaoscript
do {
	sell()
}
until supply > demand
```

## repeat

### Syntax

```syntax
repeat [*expression* times] {
	*...statements*
}
```

### Examples

```kaoscript
repeat 10 times {
	console.log('Hello world!')
}

repeat {
	// infinity loop
}
```

## match

Unlike JavaScript's `switch`, in kaoscript, `match` won't automatically cascade.
It executes only and only one branch. (No `break` needed)

### Syntax

```syntax
match
	*expression*
	|
	var [mut] *varname* [: *type*] = *expression*
{
	(
		(
			*match-condition*
			[with ([mut] *varname* [: *type*] | *destructuring*) ]
			[when *expression:Boolean*]
		)
		|
		(
			with ([mut] *varname* [: *type*] | *destructuring*)
			[when *expression:Boolean*]
		)
		|
		(when *expression:Boolean*)
		|
		else
	)
	(
		=> *expression*
		|
		{
			*...statements*
		}
	)
}

match-condition = (
	(*expression1* [| ... *expressionN*]\*)
	|
	is (*class1* [| ... *classN*]\*
) [, ...*match-condition*]*
```

### Examples

```kaoscript
match number {
	1					=> console.log("One!")
	2 | 3 | 5 | 7 | 11	=> console.log("This is a prime")
	13..19				=> console.log("A teen")
	else				=> console.log("Ain't special")
}
```

```kaoscript
match age() {
	0					=> console.log(`I'm not born yet I guess`)
	1  .. 12 	with n	=> console.log(`I'm a child of age \(n)`)
	13 .. 19 	with n	=> console.log(`I'm a teen of age \(n)`)
	else		with n	=> console.log(`I'm an old person of age \(n)`)
}
```

```kaoscript
var somePoint = [1, 1]

match somePoint {
	[0, 0]			=> console.log(`(0, 0) is at the origin`)
	[_, 0]			=> console.log(`(\(somePoint[0]), 0) is on the x-axis`)
	[0, _]			=> console.log(`(0, \(somePoint[1])) is on the y-axis`)
	[-2..2, -2..2]	=> console.log(`(\(somePoint[0]), \(somePoint[1])) is inside the box`)
	else			=> console.log(`(\(somePoint[0]), \(somePoint[1])) is outside of the box`)
}
```

```kaoscript
var somePoint = [1, 1]

match somePoint {
	with [x, y] when x == 0 && y == 0				=> console.log(`(0, 0) is at the origin`)
	with [x, y] when y == 0							=> console.log(`(\(x), 0) is on the x-axis`)
	with [x, y] when x == 0							=> console.log(`(0, \(y)) is on the y-axis`)
	with [x, y] when -2 <= x <= 2 && -2 <= y <= 2	=> console.log(`(\(x), \(y)) is inside the box`)
	with [x, y]										=> console.log(`(\(x), \(y)) is outside of the box`)
	else											=> console.log(`Not a point`)
}
```

```kaoscript
var value = {
	foo: 1
	bar() => 2
}

match value {
	{foo: 1}	with {qux: n} 			=> console.log(`qux: \(n)`)
	{foo: 1} 							=> console.log('foo: 1')
	{foo}								=> console.log('has foo')
	{qux}								=> console.log('has qux')
				when value.bar() == 0	=> console.log('bar() == 0')
	else								=> console.log('oops!')
}
```

```kaoscript
match view {
	is UIImageView								=> console.log("It's an image view")
	is UILabel		with label					=> console.log("It's a label")
	is UITableView	with tblv					{
		var sectionCount = tblv.numberOfSections()
		console.log(`It's a table view with \(sectionCount) sections`)
	}
	else										=> console.log("It's some other UIView or subclass")
}
```

### fallthrough

For cascading, the `fallthrough` statement is required

```kaoscript
func foobar(d) {
	match d {
		'hour' {
			console.log('hour')

			fallthrough
		}
		'minute' {
			console.log('minute')

			fallthrough
		}
		'second' {
			console.log('second')
		}
	}
}
```

## break

The `break` statement ends execution of an entire control flow statement immediately.


### Syntax

```syntax
break [*label*] [
	if *expression:Boolean*
	|
	unless *expression:Boolean*
]
```

## continue

The `continue` statement tells a loop to stop what it is doing and start again at the beginning of the next iteration through the loop.

### Syntax

```syntax
continue [*label*] [
	if *expression:Boolean*
	|
	unless *expression:Boolean*
]
```

## block

The `block` statement can be used with `break` or `continue` statements to prematurely leave or restart any loops.

### Examples

```kaoscript
block top {
	echo('entering block')

	for var i from 1 to 10 {
		for var j from 1 to 10 {
			echo(`looping \(i).\(j)`)

			if i == 5 {
				// let's leave the block (and the loops)
				break top
			}
		}
	}

	echo('still in block') // never printed
}

echo('outside the block')
```

### Syntax

```syntax
block *label* {
	...statements
}

*label* = *varname*
```

## with

### Examples

```kaoscript
with var file = open() {
	var text = async file.readText()
}
finally {
	file.close()
}

with {
	var file = open()
	var file2 = open2()
}
then {
	var text = async file.readText()
}
finally {
	file.close()
}
```

```kaoscript
var mut mode = 2

with mode += 12 {
	// mode = 14
}

// mode = 2
```

### Syntax

```syntax
with *var-init* {
	...statements
}
[finally {
	...statements
}]

with {
	(*var-init*)+
}
then {
	...statements
}
[finally {
	...statements
}]

var-init = (
	var [mut] *varname* = *expression*
	|
	*variable* (=|+=|-=|\*=|/=|/.=|%=|&&=|"||="|^^=|<<=|>>=) *expression*
)

variable = [@]*varname*(\.*varname* | "[" *expression* "]")\*
```

## pass

The `pass` statement indicates that the block should be empty. No others statements should be around that statement.

It can be useful to split complicated condition into more readable `if/else` statements and a branch needs to be empty.

### Syntax

```syntax
pass
```
