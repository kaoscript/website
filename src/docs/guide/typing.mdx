---
name: Typing
menu: Guide
route: /guide/typing
---

# Typing

## basic types

|    name    | alias  |
|:----------:|:------:|
|    Any     |  any   |
|   Array    | array  |
|  Boolean   |  bool  |
|   Class    | class  |
|    Date    |  date  |
|    Enum    |  enum  |
|   Error    |        |
|  Function  |  func  |
| Namespace  |        |
|   Never    | never  |
|   Number   | number |
|   Object   | object |
| Primitive  |        |
|   RegExp   | regex  |
|   String   | string |
|    Void    |  void  |

The following types are **only** useable **as return type** of a function:
- `Never`/`never`
- `Void`/`void`

## any

`Any` is a type that represents any types (except for `Void` and `Never`).

```kaoscript
var mut tmp: Any = 42

tmp = 'White'
```

## void

`Void` is the return type of a function that does not return any value.
Since, it doesn't generate any value, it can't be used as a part of an operation.

```kaoscript
func hello(): void {
	console.log('Hello!')
}

hello()
// print: Hello!

var x = hello()
// throw an error
```

## never

`Never` is the return type of a function that does not return normally, i.e. that will always throw an error.

```kaoscript
func throwError(message: String): never {
	throw Error.new(message)
}
```

## primitive

`Primitive` is a type that represents an union of the following types:

- `Boolean`
- `Number`
- `String`

## array

```kaoscript
var x = [1, 2, 3, 4]
```

```kaoscript
func foobar(x: [Number, Number, ...String]) {}
// x[0]: Number
// x[1]: Number
// x[2]: String
// x[*]: String

func foobar(x: [Number, Number, ...]) {}
// x[0]: Number
// x[1]: Number
// x[2]: Any?
// x[*]: Any?
```

## object

An object is any data structure which can contain a named property.
It can be any of the following type:
- a plain `Object`
- an instance of a `Class` or `Struct`

In kaoscript, the object in `x = {}` doesn't contain any default properties (no `toString()`, ...).

### finite

```kaoscript
var x: {foo: Number, bar: String} = {
	foo: 0
	bar: ''
}
```

```kaoscript
func foobar(x: {foo: Number, bar: String}) {}
// x.foo: Number
// x.bar: String
// x.qux throws an error

func foobar(x: {
	foo: Number
	bar: String
}) {}
// same definition as previous
```

An instance of a `Class` or `Struct` can only be represented by a finite object.

### infinite

```kaoscript
var x = {}

var x = {
	foo: 0
	bar: ''
}
```

```kaoscript
func foobar(x: {
	...String
}) {}
// x.foo: String
// x.bar: String
// x.qux: String
// x.*: String

func foobar(x: {
	foo: Number
	bar: Number
	...String
}) {}
// x.foo: Number
// x.bar: Number
// x.qux: String
// x.*: String

func foobar(x: {
	foo: Number
	bar: Number
	...
}) {}
// x.foo: Number
// x.bar: Number
// x.qux: Any?
// x.*: Any?
```

## nullable

You can define a variable as nullable.

```kaoscript
var x?
// type: Any, nullable

var y: Number?
// type: Number, nullable
```

## alias

Type aliases create a new name for a type.

```kaoscript
type T = number | string

var mut n: T = 42
```

## union

Union type defines the variable as been one of the given types.

```kaoscript
var mut x: String | Number

x = 42
x = 'foobar'

x = true
// throw an error
```

### null

The null can be expressed with:
```kaoscript
var mut x: String|Number|Null
```
or
```kaoscript
var mut x: String|Number|?
```

## fusion

A fusion type is a combination of several types.

```kaoscript
type RegExpExecArray = Array<String?> & {
    index: Number
    input: String
}
```

## exclusion

An exclusion type represents an union type without one or more types.

## generic type

kaoscript has a very basic support for generics.

In array or object, it's used to inference the type of the elements.

```kaoscript
var mut values: Array<String> = ['foo', 'bar', 'qux']

var x = values[0]
// type: String
```

### aliases

|           full            |           rest           |     short      |
| :-----------------------: | :----------------------: | :------------: |
|      `Array<String>`      |     `[ ...String ]`      |   `String[]`   |
|     `Object<String>`      |     `{ ...String }`      |   `String{}`   |
| `Array<Array<String?>>?`  | `[ ...[ ...String? ] ]?` | `String?[][]?` |
| `Array<Object<String?>>?` | `[ ...{ ...String? } ]?` | `String?{}[]?` |

## type checking

kaoscript used the keywords `is` and `is not` to be able to test the type of a variable.

```kaoscript
if x is String {

}

if x is not String {

}
```

## type casting

The keyword `as` allows complex types but it would need to be surrounded by parentheses

```kaoscript
(x as String).toLowerCase()

(x as String | Number).toFloat()
```

If the type is an identifier, you can use `:`. But for complex types, you will need to create aliases.

```kaoscript
x:String.toLowerCase()

type T = String | Number
x:T.toFloat()
```

At runtime, `as` and `:` throw an error when the value doesn't match the type.

You can use `as?` or `:?` to return `null` when the value doesn't match the type.

```kaoscript
func foobar(p: Point) {
	if var d3 = p as? Point3D {
		console.log(d3.x + 1, d3.y + 2, d3.z + 3)
	}
}
```

You can avoid the type casting with `as!` or `:!`.

```syntax
*expression*:[(!|?)]*limited-type*(?|'[]'|'{}')\*

*expression* as[(!|?)] *type*
```

## type matching

To match a type, you can use the unary operators `!?` or `!!`.

If `x`'s type is `Number?`, then `x!?` is `Number`.

```kaoscript
func foobar(): Number? {
	return 42
}

func quxbaz(x: Number) {
}

quxbaz(foobar()!?)
```

`!!` forces the type to be same as the expected type.

```kaoscript
func foobar(): Number | String {
	return 42
}

func quxbaz(x: Number) {
}

quxbaz(foobar()!!)
```

## inference

If a variable is not typed, kaoscript willl automatically deduce its type based on the current value.

```kaoscript
var mut name = 'John'
// type: String

name = 42
// type: Number

func foobar() {
	return 'hello'
}

name = foobar()
// no type
```

## subset/superset

Due to the complex nature of overloading functions with the features like named or rest argument, kaoscript uses the concept of *subset* / *superset*. ([wikipedia](https://en.wikipedia.org/wiki/Subset))

It isn't new since it's already exists: a superclass is a subset of a subclass *(superclass ⊂ subclass)*, meaning, a subclass contains all the features (variables, methods) of the superclass.

A function `funcB` is subset of the function `funcA` *(funcB ⊂ funcA)* only and only if the function `funcB`:
- **accepts <ins>at least</ins>** all the arguments of `funcA` <small>(A ⊂ B)</small>
- **returns <ins>at most</ins>** the return of `funcA` <small>(B ⊂ A)</small>
- **throws <ins>at most</ins>** all the exceptions of `funcA` <small>(B ⊂ A)</small>

The function `(a: Any)` is subset of the function `(a: Any? = ?, b: Any? = ?)`.
The function `()` is subset of the function `(done: Function? = ?): Void`.

The type of argument must be a superset of the type of the parameter *(parameter ⊂ argument)*. *(What can do more, can do less)*

## syntax

```syntax
type-statement = "type" *varname* = *type*

type = (
	(
		*varname* ('.' *varname*)\* ['<' *type* ([,] *type*)\* '>']
		|
		[async] [func] *func-type*
		|
		*object-type*
		|
		*array-type*
	) (? | '[]' | '{}')\* (('|' | & | ^) *type* | '|?')\*
	|
	typeof *expression*
)

descriptive-type = (
	([(final | sealed)] [abstract] | [system]) class *class-type*
	|
	[async] [func] *varname* *func-type*
	|
	[sealed] namespace *namespace-type*
	|
	bitmask *bitmask-type*
	|
	enum *enum-type*
	|
	struct *struct-type*
	|
	tuple *tuple-type*
	|
	type *varname* = *type*
	|
	[sealed] [var] *varname*[: *type*]
)

limited-type = (*func-type* | *object-type* | *array-type* | *varname* ('.' *varname*)\* ['<' *limited-type* ([,] *limited-type*)\* '>'])

generic-type = *entity-type* (',' *entity-type*)\*
entity-type = *varname* ('.' *varname*)\*

array-type = '['
	(
		(
			*type*
			|
			...[*type*]
		) [,]
	)+
']'

class-type = *varname*['<' *generic-type* '>'] [extends *varname*] [{
	...
}]

func-type = '(' [[*parameter1*] [, [*parameter2*] ... [, [*parameterN*]]] ')' [: *return-type*] [~ *class1* [, *class2* ... [, *classN*]]]

object-type = '{'
	(
		(
			*varname*[: *type*] [?]
			|
			[async] [func] *varname* *func-type*
			|
			...[*type*]
		) [,]
	)+
'}'

param-type = *type* [( "||" *type* | "&&" *type* )+]

namespace-type = *varname* [{
	(*descriptive-type*)\+
}]

return-type = (
	[new] *type*
	|
	valueof *expression*
)
```
