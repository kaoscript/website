---
name: Typing
menu: Guide
route: /guide/typing
---

# Typing

## basic types

|    name    | alias  |
|:----------:|:------:|
|    Any     |  any   |
|   Array    | array  |
|  Boolean   |  bool  |
|   Class    | class  |
|    Date    |  date  |
| Dictionary |  dict  |
|    Enum    |  enum  |
|   Error    |        |
|  Function  |  func  |
| Namespace  |        |
|   Never    | never  |
|   Number   | number |
|   Object   | object |
| Primitive  |        |
|   RegExp   | regex  |
|   String   | string |
|    Void    |  void  |

The following types are **only** useable **as return type** of a function:
- `Never`/`never`
- `Void`/`void`

## any

`Any` is a type that represents any types (except for `Void` and `Never`).

```kaoscript
var mut tmp: Any = 42

tmp = 'White'
```

## void

`Void` is the return type of a function that does not return any value.
Since, it doesn't generate any value, it can't be used as a part of an operation.

```kaoscript
func hello(): void {
	console.log('Hello!')
}

hello()
// print: Hello!

var x = hello()
// throw an error
```

## never

`Never` is the return type of a function that does not return normally, i.e. that will always throw an error.

```kaoscript
func throwError(message: String): never {
	throw new Error(message)
}
```

## primitive

`Primitive` is a type that represents an union of the following types:

- `Boolean`
- `Number`
- `String`

## object

`Object` is a type that represents an exclusion of the following types from type `Any`:

- `Array`
- `Boolean`
- `Dictionary`
- `Enum`
- `Function`
- `Namespace`
- `Number`
- `String`

## array

```kaoscript
func foobar(x: [Number, Number]) {}
// x[0]: Number
// x[1]: Number
// x[2] throws an error
```

### rest

```kaoscript
func foobar(x: [Number, Number, ...String]) {}
// x[0]: Number
// x[1]: Number
// x[2]: String
// x[*]: String
```

## dictionary

```kaoscript
func foobar(x: {foo: Number, bar: String}) {}
// x.foo: Number
// x.bar: String
// x.qux throws an error

func foobar(x: {
	foo: Number
	bar: String
}) {}
// same definition as previous
```

### rest

```kaoscript
func foobar(x: {
	...String
}) {}
// x.foo: String
// x.bar: String
// x.qux: String
// x.*: String

func foobar(x: {
	foo: Number
	bar: Number
	...String
}) {}
// x.foo: Number
// x.bar: Number
// x.qux: String
// x.*: String
```

## nullable

You can define a variable as nullable.

```kaoscript
var x?
// type: Any, nullable

var y: Number?
// type: Number, nullable
```

## alias

Type aliases create a new name for a type.

```kaoscript
type T = number | string

var mut n: T = 42
```

## union

Union type defines the variable as been one of the given types.

```kaoscript
var mut x: String | Number

x = 42
x = 'foobar'

x = true
// throw an error
```

### null

The null can be expressed with:
```kaoscript
var mut x: String|Number|Null
```
or
```kaoscript
var mut x: String|Number|?
```

## fusion

A fusion type is a combination of several types.

```kaoscript
type RegExpExecArray = Array<String?> & {
    index: Number
    input: String
}
```

## exclusion

An exclusion type represents an union type without one or more types.

```kaoscript
type Instance = Object ^ Array ^ Enum ^ Function ^ Namespace
// Instance is the type Object without the types: Array, Enum, Function, Namespace
```

## generic type

kaoscript has a very basic support for generics.

In array or dictionary, it's used to inference the type of the elements.

```kaoscript
var mut values: Array<String> = ['foo', 'bar', 'qux']

var x = values[0]
// type: String
```

### aliases

|             full              |           rest           |     short      |
| :---------------------------: | :----------------------: | :------------: |
|        `Array<String>`        |     `[ ...String ]`      |   `String[]`   |
|     `Dictionary<String>`      |     `{ ...String }`      |   `String{}`   |
|   `Array<Array<String?>>?`    | `[ ...[ ...String? ] ]?` | `String?[][]?` |
| `Array<Dictionary<String?>>?` | `[ ...{ ...String? } ]?` | `String?{}[]?` |

## syntax

```syntax
type = (
	*limited-type*
	|
	[async] [func] *functype*
	|
	{
		(
			(
				*varname*: *type*
				|
				[async] [func] *varname* *functype*
				|
				...*type*
			) [,]
		)+
	}
	|
	'['
		([[...] *type*] [,])+
	']'
) (('|' | & | ^) *type* | '|?')\*

limited-type = (*varname* ('.' *varname*)\* | *functype*) ['<' *limited-type* ([,] *limited-type*)\* '>'] (? | '[]' | '{}')\*

generic-type = *entity-type* (',' *entity-type*)\*
entity-type = *varname* ('.' *varname*)\*

functype = '(' [[*parameter1*] [, [*parameter2*] ... [, [*parameterN*]]] ')' [: *type*] [~ *class1* [, *class2* ... [, *classN*]]]
```

## type checking

kaoscript used the keywords `is` and `is not` to be able to test the type of a variable.

```kaoscript
if x is String {

}

if x is not String {

}
```

## type casting

The keyword `as` allows complex types but it would need to be surrounded by parentheses

```kaoscript
(x as String).toLowerCase()

(x as String | Number).toFloat()
```

If the type is an identifier, you can use `:`. But for complex types, you will need to create aliases.

```kaoscript
x:String.toLowerCase()

type T = String | Number
x:T.toFloat()
```

At runtime, `as` and `:` throw an error when the value doesn't match the type.

You can use `as?` or `:?` to return `null` when the value doesn't match the type.

```kaoscript
func foobar(p: Point) {
	if var d3 = p as? Point3D {
		console.log(d3.x + 1, d3.y + 2, d3.z + 3)
	}
}
```

You can avoid the type casting with `as!` or `:!`.

```syntax
*expression*:[(!|?)]*limited-type*

*expression* as[(!|?)] *type*
```

## type matching

To match a type, you can use the unary operators `!?` or `!!`.

If `x`'s type is `Number?`, then `x!?` is `Number`.

```kaoscript
func foobar(): Number? {
	return 42
}

func quxbaz(x: Number) {
}

quxbaz(foobar()!?)
```

`!!` forces the type to be same as the expected type.

```kaoscript
func foobar(): Number | String {
	return 42
}

func quxbaz(x: Number) {
}

quxbaz(foobar()!!)
```

## inference

If a variable is not typed, kaoscript willl automatically deduce its type based on the current value.

```kaoscript
var mut name = 'John'
// type: String

name = 42
// type: Number

func foobar() {
	return 'hello'
}

name = foobar()
// no type
```
