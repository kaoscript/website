---
name: Basic Operators
menu: Guide
route: /guide/basic-operators
---

# Basic Operators

> :construction: kaoscript will allow to override operators.

## string

|     Operator      |    Meaning    |
| :---------------: | :-----------: |
| *expr* `+` *expr* | Concatenation |

```kaoscript
'foo' + 'bar'	// foobar
```

## arithmetic

|      Operator      |      Meaning       |
| :----------------: | :----------------: |
|     `-`*expr*      |      Negative      |
| *expr* `-` *expr*  |    Subtraction     |
| *expr* `+` *expr*  |      Addition      |
| *expr* `*` *expr*  |   Multiplication   |
| *expr* `**` *expr* |       Power        |
| *expr* `/` *expr*  |      Division      |
| *expr* `%` *expr*  |     Remainder      |
| *expr* `%%` *expr* |      Modulus       |
| *expr* `/#` *expr* |  Integer division  |
| *expr* `/&` *expr* | Euclidean division |
<!--
| *expr* `\` *expr*  |   Left division    |
| *expr* `\#` *expr* |  Integer left division   |
| *expr* `\&` *expr* | Euclidean left division  |
-->

```kaoscript
1 + 2			// 3
1 + 2 + 3		// 6
1 - 2			// -1
2 * 3			// 6
18 / 3			// 6
28 / 5			// 5.6
28 /# 5			// 5
28 /& 5			// [5, 3]
18 % 3			// 0
28 % 5			// 3
28 % 10 % 5		// 3
-2				// -2
```

Unlike JavaScript, if an operand is `null`, the result will be `null`. And if an operand is not a number, an error will be thrown.

### remainder

```kaoscript
[x % 3 for x in -5..5]		// [-2, -1, 0, -2, -1, 0, 1, 2, 0, 1, 2]
[x % -3 for x in -5..5]		// [-2, -1, 0, -2, -1, 0, 1, 2, 0, 1, 2]
```

### modulus

```kaoscript
[x %% 3 for x in -5..5]		// [1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2]
[x %% -3 for x in -5..5]	// [-2, -1, 0, -2, -1, 0, -2, -1, 0, -2, -1]
```

### division

The euclidean division operators return result as `[quotient, remainder]`

## comparison

|      Operator      |        Meaning        |
|:------------------:|:---------------------:|
| *expr* `==` *expr* |         Equal         |
| *expr* `!=` *expr* |       Not equal       |
| *expr* `>` *expr*  |     Greater than      |
| *expr* `<` *expr*  |       Less than       |
| *expr* `>=` *expr* | Greater than or equal |
| *expr* `<=` *expr* |  Less than or equal   |
| *expr* `~~` *expr* |       Matching        |
| *expr* `!~` *expr* |     Not matching      |
| *expr* `&` *expr*  |  Junctive AND (all)   |
| *expr* `|` *expr*  |   Junctive OR (any)   |
| *expr* `^` *expr*  |  Junctive XOR (one)   |

```kaoscript
1 == 1			// true
1 == 1 == 2		// false
1 != 2			// true
3 > 2 > 1		// true
3 < 5 < 1		// false
3 <= 3 <= 5		// true
4 >= 1			// true
```

### Chaining comparisons

Comparisons can be chained.

```kaoscript
1 < 2 <= 2 < 3 == 3 > 2 >= 1 == 1 < 3 != 5
// true

if 1 < x() < 42 {
	// `x()` is evaluated only once, its result is saved in a temporary variable
}
```

### Junctive operations

Both following statements are equivalent:

```kaoscript
if color == 'white' | 'black' | 'gray' | 'grey' {
}

if color == 'white' || color == 'black' || color == 'gray' || color == 'grey' {
}
```

## logical

The following operations are only valid for boolean operands.

|      Operator      | Meaning  |
|:------------------:|:--------:|
|     `!`*expr*      | Negation |
| *expr* `&&` *expr* |   And    |
| *expr* `||` *expr* |    Or    |
| *expr* `^^` *expr* |   Xor    |
| *expr* `->` *expr* |  Imply   |

```kaoscript
!true			// false
true || false	// true
true && false	// false
true ^^ false	// true
true -> false	// false
```

|  `x`  |  `y`  | `x || y` | `x && y` | `x ^^ y` | `x -> y` |
|:-----:|:-----:|:--------:|:--------:|:--------:|:--------:|
| false | false |  false   |  false   |  false   |   true   |
| false | true  |   true   |  false   |   true   |   true   |
| true  | false |   true   |  false   |   true   |  false   |
| true  | true  |   true   |   true   |  false   |   true   |

## bitwise & shift

The following operations are only valid for numeric operands.

|      Operator       |   Meaning   |
| :-----------------: | :---------: |
|      `+^`expr*      |     Not     |
| *expr* `+&` *expr*  |     And     |
| *expr* `+|` *expr*  |     Or      |
| *expr* `+^` *expr*  |     Xor     |
| *expr* `+<` *expr*  | Shift left  |
| *expr* `+>` *expr*  | Shift right |


```kaoscript
0x22 +& 0x0f    // 0x02
0x22 +| 0x0f    // 0x2f
0x22 +^ 0x0f    // 0x2d
0x22 +< 4       // 0x220
0x22 +> 4       // 0x02
```

## conditional

|           Operator           |          Meaning          |
| :--------------------------: | :-----------------------: |
|          `?`*expr*           |        Existential        |
|          `?#`*expr*          |         Non empty         |
|          `?|`*expr*          |       Variant(true)       |
|          `?+`*expr*          |          Finite           |
|      *expr* `??` *expr*      |      Null coalescing      |
|     *expr* `?##` *expr*      |     Empty coalescing      |
|     *expr* `?||` *expr*      | Variant(false) coalescing |
|     *expr* `?++` *expr*      |   Not finite coalescing   |
| *expr* `?` *expr* `:` *expr* |     Ternary condition     |

### Examples

```kaoscript
if ?value {
	// `value` is not null
}

t = x ?? y ?? z			// `t` is equal to the first not-null variable from `x`, `y` or `z` (in that order)

x = y == 42 ? 0 : 1		// `x` is equal to 0 is `y` equals `42`, if not `1`
```

The operator `??` is a polyadic operator.

### Distribution

| `x`  | `null`  |  `''`   | `'x'`  |  `[]`   | `[1,2,3]` |  `{}`   | `{ foo: 0 }` |
| :--: | :-----: | :-----: | :----: | :-----: | :-------: | :-----: | :----------: |
| `?x` | `false` | `true`  | `true` | `true`  |  `true`   | `true`  |    `true`    |
| `#x` | `false` | `false` | `true` | `false` |  `true`   | `false` |    `true`    |

## typing

|            Operator            |         Meaning         |
| :----------------------------: | :---------------------: |
|   *expr* `is` *limited-type*   |      Type equality      |
| *expr* `is not` *limited-type* |     Type inequality     |
|      *expr*`:!(`*type*`)`      |     Type signalment     |
|     *expr*`:!!(`*type*`)`      | Forced type signalment  |
|      *expr*`:&(`*type*`)`      |     Type assertion      |
|     *expr*`:&?(`*type*`)`      | Nullable type assertion |
|      *expr*`:>(`*type*`)`      |      Type casting       |
|     *expr*`:>?(`*type*`)`      |  Nullable type casting  |
|           *expr*`!?`           |  Null removal fitting   |
|           *expr*`!!`           |   Forced type fitting   |

### type signalment

Type signalment indicates to the compiler the type of the variable.
- `x:!(target-type)` only checks if `x` can be of the target type.
- `x:!!(target-type)` no checks are done.

### type assertion

Type assestion check if the variable if of the target type. No memory changes
- `x:&(target-type)` asserts that `x` is of the target type. Returns `x` if true, else fails.
- `x:&?(target-type)` asserts that `x` is of the target type. Returns `x` if true, else `null`.

### type casting

Type casting converts the variable to the target type. Memory changes can happens. Immutable variables can't be casted.
- `x:>(target-type)` casts that `x` is of the target type. Returns `x` if true, else fails.
- `x:>?(target-type)` casts that `x` is of the target type. Returns `x` if true, else `null`.

### example

```kaoscript
class Foobar {
}

if x is Foobar {
	// `x`'s type is `Foobar`
}

if x is not Foobar {
	// `x`'s type isn't `Foobar`
}

t = x:!(String).toUpperCase()

t = x:!(Array<String>)
```

## assignment

|           Operator           |          Meaning          |
| :--------------------------: | :-----------------------: |
|      *expr* `=` *expr*       |        Assignment         |
|      *expr* `<-` *expr*      |  Assignment with return   |
|      *expr* `-=` *expr*      |        Subtraction        |
|      *expr* `+=` *expr*      |         Addition          |
|      *expr* `*=` *expr*      |      Multiplication       |
|     *expr* `**=` *expr*      |           Power           |
|      *expr* `/=` *expr*      |         Division          |
|     *expr* `/#=` *expr*      |     Integer division      |
|      *expr* `%=` *expr*      |         Remainder         |
|     *expr* `%%=` *expr*      |          Modulus          |
|     *expr* `&&=` *expr*      |        And logical        |
|     *expr* `||=` *expr*      |        Or logical         |
|     *expr* `^^=` *expr*      |        Xor logical        |
|     *expr* `+&=` *expr*      |        And bitwise        |
|     *expr* `+|=` *expr*      |        Or bitwise         |
|     *expr* `+^=` *expr*      |        Xor bitwise        |
|     *expr* `+<=` *expr*      |        Shift left         |
|     *expr* `+>=` *expr*      |        Shift right        |
|      *expr* `?=` *expr*      |        Existential        |
|     *expr* `!?=` *expr*      |      Non existential      |
|     *expr* `??=` *expr*      |      Null coalescing      |
|     *expr* `?#=` *expr*      |         Non empty         |
|     *expr* `!?#=` *expr*     |           Empty           |
|     *expr* `?##=` *expr*     |     Empty coalescing      |
|     *expr* `?|=` *expr*      |       Variant(true)       |
|     *expr* `!?|=` *expr*     |      Variant(false)       |
|     *expr* `?||=` *expr*     | Variant(false) coalescing |
|     *expr* `?+=` *expr*      |          Finite           |
|     *expr* `!?+=` *expr*     |        Not finite         |
|     *expr* `?++=` *expr*     |   Not finite coalescing   |
<!--
| *expr* `:!=` *limited-type*  |      Type signalment      |
| *expr* `:!!=` *limited-type* |  Forced type signalment   |
| *expr* `:&=` *limited-type*  |      Type assertion       |
| *expr* `:&?=` *limited-type* |  Nullable type assertion  |
| *expr* `:>=` *limited-type*  |       Type casting        |
| *expr* `:>?=` *limited-type* |   Nullable type casting   |
-->

Unlike the assignment operator in JavaScript, the assignment operators don't return a value, except:
- `?=`, `?#=`, `?|=` and `?+=` will return `true` when the assignment is **successful**. If not, `false`.
- `!?=`, `!?#=`, `!?|=` and `!?+=` will return `true` when the assignment is **unsuccessful**. If not, `false`.
- `<-` is the same as `=` but returns the assigned value.

### Distribution

|    `x`    |    `y`    | `x ?= y` | `x ??= y` | `x ?#= y` | `x ?##= y` |
| :-------: | :-------: | :------: | :-------: | :-------: | :--------: |
|  `null`   |  `null`   |    ❌    |    ✅     |    ❌     |     ✅     |
|  `null`   |    `0`    |    ✅    |    ✅     |    ❌     |     ✅     |
|  `null`   | `[1,2,3]` |    ✅    |    ✅     |    ✅     |     ✅     |
|   `''`    |  `null`   |    ❌    |    ❌     |    ❌     |     ✅     |
|   `''`    |    `0`    |    ✅    |    ❌     |    ❌     |     ✅     |
|   `''`    |  `'abc'`  |    ✅    |    ❌     |    ✅     |     ✅     |
|   `''`    | `[1,2,3]` |    ✅    |    ❌     |    ✅     |     ✅     |
|  `'xyz'`  |  `null`   |    ❌    |    ❌     |    ❌     |     ❌     |
|  `'xyz'`  |    `0`    |    ✅    |    ❌     |    ❌     |     ❌     |
|  `'xyz'`  |  `'abc'`  |    ✅    |    ❌     |    ✅     |     ❌     |
|  `'xyz'`  | `[1,2,3]` |    ✅    |    ❌     |    ✅     |     ❌     |
|   `[]`    |  `null`   |    ❌    |    ❌     |    ❌     |     ✅     |
|   `[]`    |    `0`    |    ✅    |    ❌     |    ❌     |     ✅     |
|   `[]`    |  `'abc'`  |    ✅    |    ❌     |    ✅     |     ✅     |
|   `[]`    | `[1,2,3]` |    ✅    |    ❌     |    ✅     |     ✅     |
| `[4,5,6]` |  `null`   |    ❌    |    ❌     |    ❌     |     ❌     |
| `[4,5,6]` |    `0`    |    ✅    |    ❌     |    ❌     |     ❌     |
| `[4,5,6]` |  `'abc'`  |    ✅    |    ❌     |    ✅     |     ❌     |
| `[4,5,6]` | `[1,2,3]` |    ✅    |    ❌     |    ✅     |     ❌     |

- ✅ indicates that the assignment is **successful**
- ❌ indicates that the assignment is **unsuccessful**

## function

|         Operator          |             Meaning              |
| :-----------------------: | :------------------------------: |
|  *expr*`(`*arguments*`)`  |       Function application       |
| *expr*`?(`*arguments*`)`  | Conditional function application |
| *expr*`^$(`*arguments*`)` |          Curry function          |
| *expr*`^^(`*arguments*`)` |          Curry function          |
| *expr*`*$(`*arguments*`)` |       Function application       |
|    *expr* `|>` *expr*     |         Forward pipeline         |
|    *expr* `<|` *expr*     |        Backward pipeline         |

## others

|      Operator       |          Meaning           |
| :-----------------: | :------------------------: |
|      `#`*expr*      |      Length operator       |
|   *expr*`.`*name*   |       Member access        |
|  *expr*`?.`*name*   | Conditional member access  |
| *expr*`[`*expr*`]`  |        Array access        |
| *expr*`?[`*expr*`]` |  Conditional array access  |
|      `.`*name*      |      Implicit member       |
|     `..`*expr*      |      Rolling operator      |
|     `...`*expr*     |      Spread operator       |
|    `...?`*expr*     | Null-aware spread operator |
