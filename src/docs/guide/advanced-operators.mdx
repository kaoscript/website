---
name: Advanced Operators
menu: Guide
route: /guide/advanced-operators
---

# Advanced Operators

## spread operator

Spread syntax can be used when all elements from an object or array need to be included in a new array or object, or should be applied one-by-one in a function call's arguments list. There are three distinct places that accept the spread syntax:

- array expression
- object expression
- function arguments

### array expression

```kaoscript
var original = [1, 2]
var copy = [...original, 3]
// copy = [1, 2, 3]
```

### object expression

```kaoscript
var original = { a: 1, b: 2 }
var copy = { ...original, c: 3 }
// copy = { a: 1, b: 2, c: 3 }
```

### function arguments

```kaoscript
func foo(x, y, z) {
}

var args = [0, 1, 2]

foo(...args)
// foo(1, 2, 3)
```

### null-awareness

By default, the operator `...` only supports array or object and will throw an error if any other value, including `null`, is passed.

The derived operator `...?` will allow a `null` value to be passed as argument but it won't be added to the array or object.

```kaoscript
var allValues = [42, ...additionalValues, ...?optionalValues]
echo(allValues)
```

### filtering

```kaoscript
func foobar(value) {
	return {
		...value { x, y }
	}
	// { x: value.x, y: value.y }
}
```

### syntax

<!-- ```syntax
spread-expression = '...' *expression* [(
	'{' *varname* ['%' *varname*] (',' *varname* ['%' *varname*])\* '}'
	|
	'[' *number* ['..' *number*] (',' *number* ['..' *number*])\* ']'
)]
``` -->
```syntax
spread-expression = '...' [?] *expression* [(
	'{' *varname* ['%' *varname*] (',' *varname* ['%' *varname*])\* '}'
)]
```

## rolling notation

### summary

- multi-lines only
- conditional expression
- operators:
	- `..`: rolling
	- `.`:  member access
	- `?.`: conditional member access
- a rolling notation must the the same class of operators (rolling operator or member access operators)

### basic example

```kaoscript
getAddress()
  ..setStreet('Elm', '13a')
  ..city = 'Carthage'
  ..state = 'Eurasia'
  ..zip(66666, extended: 6666)

// same as
var address = getAddress()
address.setStreet('Elm', '13a')
address.city = 'Carthage'
address.state = 'Eurasia'
address.zip(66666, extended: 6666)
```

### example with conditional expression

```kaoscript
var shape = Ellipse.new(10, 20)
	..rotation = 45 * Math.PI / 180 if filterRotate()
	..color = 'rgb(0,129,198)'
	..outlineWidth = 0

// same as
var shape = Ellipse.new(10, 20)

if filterRotate() {
	shape.rotation = 45 * Math.PI / 180
}

shape.color = 'rgb(0,129,198)'
shape.outlineWidth = 0
```

### example with existential test

```kaoscript
address?
	..setStreet('Elm', '13a')
	..city = 'Carthage'
	..state = 'Eurasia'
	..zip(66666, extended: 6666)

// same as
if ?address {
	address.setStreet('Elm', '13a')
	address.city = 'Carthage'
	address.state = 'Eurasia'
	address.zip(66666, extended: 6666)
}
```

### example with member access and conditional expression

```kaoscript
writer
	.code(' ')
	.code('*') if w
	.code('|>')
	.code('?') if q
	.code('#') if h
	.code(' ')

// same as
var mut writer2 = writer.code(' ')

if w {
	writer2 = writer2.code('*')
}

writer2 = writer2.code('|>')

if q {
	writer2 = writer2.code('?')
}
if h {
	writer2 = writer2.code('#')
}

writer2.code(' ')
```

## pipeline operators

With the pipeline operators, you can write code like

```kaoscript
func getNewScore(person: { score: Number }): Number {
	var newScore = person.score
		|> double
		|> add(7, _)
		|> boundScore(0, 100, _)

	return newScore
}
```
instead of
```kaoscript
func getNewScore(person: { score: Number }): Number {
	var newScore = boundScore(0, 100, add(7, double(person.score)))

	return newScore
}
```

### Behaviors

|                    Original expression                    |                          Forward pipeline                           |              Backward pipeline              |
| :-------------------------------------------------------: | :-----------------------------------------------------------------: | :-----------------------------------------: |
|                         `o.m(x)`                          |            `x |> o.m` `x |> o.m(_)` `x |> (p) => o.m(p)`            |                 `o.m <| x`                  |
|                        `o.m(0, x)`                        |                          `x |> o.m(0, _)`                           |                     ``                      |
|                      `await o.m(x)`                       |                         `x |> o.m |> await`                         |                     ``                      |
|                           `x.i`                           |                              `x |> .i`                              |                                             |
|                          `o[x]`                           |                             `x |> o[_]`                             |                     ``                      |
|                          `x[i]`                           |                             `x |> [i]`                              |                     ``                      |
|                          `x + 1`                          |                            `x |> _ + i`                             |                     ``                      |
|                         `[0, x]`                          |                            `x |> [0, _]`                            |                     ``                      |
|                       `{ key: x }`                        |                          `x |> { key: _ }`                          |                     ``                      |
|             `fib((r <- fib(1, 1))[0], r[1])`              |                      `[1, 1] *|> fib *|> fib`                       |          `fib <|* fib <|* [1, 1]`           |
|  `?idStr ? repository.findById(parseInt(idNum)) : null`   |             `idStr |>? parseInt |> repository.findById`             | `repository.findById <| parseInt ?<| idStr` |
| `filter(map(elements, add^^(^, 1)), greaterThan^^(^, 5))` | `elements |> map(_, add^^(^, 1)) |> filter(_, greaterThan^^(^, 5))` |                                             |

`*|>` applies all the arguments from the left side to the expression on the right side
`|>?` checks for the existence of the argument on the left side. If not, it stops the pipeline and return null.

### Test operators

| Operator |    Meaning    |
| :------: | :-----------: |
|  `|>?`   |     Exist     |
|  `|>?#`  |   Non empty   |
|  `|>?|`  | Variant(true) |
|  `|>?+`  |    Finite     |
