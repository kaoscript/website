---
name: Classes
menu: Guide
route: /guide/classes
---

# Classes

## example

```kaoscript
class Shape {
	private {
		@color: String
	}

	draw(): String {
		return `I'm drawing with a \(@color) pen.`
	}
}
```

## instantiating

```kaoscript
var shape = Shape.new('red')
```

## class variable

```kaoscript
class Foobar {
	@a = 0
	// type: Number
	@b? = 0
	// type: Number?
	@c
	// type: Any?
	dyn @d = 0
	// type: Any?
	dyn @e
	// type: Any?
}
```

A non-nullable variable must be initialized by a constructor (if the variable isn't `late`)

## this aliasing

`@x` is an alias for:
- `this.x`
- `this._x`, if it's a field

```kaoscript
class Shape {
	private {
		@color: String
		// same as: _color: String
	}

	draw(): String {
		return `I'm drawing with a \(@color) pen.`
	}
}
```

## aliasing parameter

The this aliasing can also be used in parameters:

```kaoscript
class Shape {
	private {
		@color: String
	}

	constructor(@color)
	// automatically set the instance variable '_color' as the parameter 'color'
}
```

### Non-null

```kaoscript
class Shape {
	private {
		@color: String?
	}

	constructor(@color!?)
	// constructor only accepted non-null String
}
```

## constructor

```kaoscript
class Shape {
	private @color: String

	constructor() {
		@color = 'red'
	}
}

var s = Shape.new()
```

## destructor

```kaoscript
extern console

class Shape {
	private {
		@color: String
	}

	constructor(@color)

	destructor() {
		@color = null
	}
}

var s = Shape.new('red')

s.destroy()
// the destructor is called and the variable `s` is unreferenced
```

## method

### return type

`valueof this` indicates that a method always return the active instance `this`.


```kaoscript
class Shape {
	private {
		@color: String
	}

	color1(): valueof @color
	color1(@color): valueof this

	color2(): String => @color
	color2(@color): typeof this => this
	// color2 is almost identical to color1
}
```

|                   | active instance' class | declared class | active instance | new instance |
| :---------------: | :--------------------: | :------------: | :-------------: | :----------: |
|  `valueof this`   |           ✅           |       ❌       |       ✅        |      ❌      |
|   `typeof this`   |           ✅           |       ❌       |       ❓        |      ❓      |
| `new typeof this` |           ✅           |       ❌       |       ❌        |      ✅      |
|      `auto`       |           ❌           |       ✅       |       ❓        |      ❓      |
|      `Class`      |           ❌           |       ✅       |       ❓        |      ❓      |
|    `new Class`    |           ❌           |       ✅       |       ❌        |      ✅      |


## static

The modifier `static` declares members that are not bound to class instances.

```kaoscript
class Shape {
	private {
		@color: String
		@type: String
	}
	static {
		final RED_CIRCLE = Shape.new('circle', 'red')

		makeCircle(color: String): Shape => { 'circle', color } // deducing object type from expected return type
		makeRectangle(color: String): Shape => { 'rectangle', color }
	}
	constructor(@type, @color)
}

var rb = Shape.makeRectangle('black')
var cr = Shape.RED_CIRCLE
```

## late

The modifier `late` allows an immutable variable (`final`) to be initialized in a constructor. To be precise, it needs to be initialized in a constructor.

Mutable variables won't require any initialization.
It's up to the developer to make sure that the variable is correctly initialized when needed.

```kaoscript
class Shape {
	public {
		final late color: String
		final late type: String
	}
	constructor(@type, @color)
}

var r = Shape.new('rectangle', 'black')
console.log(r.color)
// black

r.color = 'yellow'
// throw a SyntaxException (immutable)
```

## proxy

```kaoscript
class Hello {
	hello(name: String): String => `Hello \(name).`
}

class Proxy1 {
	private @component: Hello

	constructor(@component)

	proxy hello = @component.hello
}

class Proxy2 {
	private @component: Hello?

	constructor(@component)

	proxy hello = @component.hello
	// throw an error since `@component` can not be null
}
```

## superclass & subclass

```kaoscript
extern console

class Shape {
	private {
		_color: String
	}
	constructor(@color)
	destructor() {
		@color = null
	}
	color() => @color
	color(@color) => this
	draw(): String {
		return `I'm drawing with a \(@color) pen.`
	}
}

class Rectangle extends Shape {
	draw() {
		return `\(super()) I'm drawing a \(@color) rectangle.`
	}
}

var r = Rectangle.new('black')

console.log(r.draw())
// I'm drawing with a black pen. I'm drawing a black rectangle.
```

## override

### Methods

The override `modifier` is required to extend or modify an inherited method.

```kaoscript
class Shape {
	draw(): String {
		return `I'm drawing a shape.`
	}
}

class Rectangle extends Shape {
	override draw(): String {
		return `I'm drawing a rectangle.`
	}
}
```

The method `methodB` overrides the method `methodA` only and only if *methodB ⊂ methodA*. ([subset](./typing#subsetsuperset))

```kaoscript
class Greetings {
	greet(name: String): String => `It's nice to meet you, \(name).`
}

class MyGreetings extends Greetings {
	override greet(name: Number | String) => `Hi \(name.toString())!`
}
```

### Fields

```kaoscript
class AbstractNode {
	private {
		@parent: AbstractNode?
	}
}

class Root extends AbstractNode {
	private {
		override @parent: Null
	}
}

class Node extends AbstractNode {
	private {
		override @parent: AbstractNode
	}
}
```

The overridden field needs to be subset of the original field.

## assisting method

The override `assist` is required to assist a method with a specialized method on a subset of the main method.

```kaoscript
class Person {
}
class Student extends Person {
}

class Greetings {
	greet(person: Person, message: String): String {
		return message
	}
}

class MyGreetings extends Greetings {
	assist greet(person % { name }: Student, message) {
		return `Hello \(name)! \(message)`
	}
}
```

<!-- ## final

The `final` keyword indicates that the class or the method is final. It can't be extended or augmented.

```kaoscript
final class Shape {
	draw(): String {
		return `I'm drawing a shape.`
	}
}

class Rectangle extends Shape {
}
// will throw an error
``` -->

## abstract

```kaoscript
abstract class AbstractGreetings {
	private {
		@message: String: ''
	}

	constructor() {
		this('Hello!')
	}

	constructor(@message)

	abstract greet(name): String
}

class Greetings extends AbstractGreetings {
	greet(name): String => `\(@message)\nIt's nice to meet you, \(name).`
}
```

## deduced types

When overriding (with `override` keyword) or implementing an abstract method, the type of an argument or the return can be deduced from the base method.

```kaoscript
class Greetings {
	greet(name: String): String => `It's nice to meet you, \(name).`
}

class MyGreetings extends Greetings {
	override greet(name) => `Hi \(name)!`
	// is the same as
	override greet(name: String): String => `Hi \(name)!`
}
```


```kaoscript
abstract class Greetings {
	abstract greet(name: String): String
}

class MyGreetings extends Greetings {
	greet(name) => `Hi \(name)!`
	// is the same as
	greet(name: String): String => `Hi \(name)!`
}
```

## this

```kaoscript
class Foobar {
    constructor() {
        this('John')
    }
    constructor(name: String) {
        console.log(`Hello \(name).`)
    }
    foobar() {
        this('John')
    }
    foobar(name: String) => `Hello \(name).`
}

class Quxbaz extends Foobar {
    constructor() {
        this('John')
    }
    constructor(name: String) {
        console.log(`Hi \(name)!`)
    }
    foobar(name: String) => `Hi \(name)!`
}
```

|             |         `this()`          |
| :---------: | :-----------------------: |
| constructor |   always current class    |
|   method    | current class or subclass |

## this parameter

Unlike functions, defining a `this` parameter will throw an error at compile time.
It's due that the `this` variable is always defined due to been a method. It will always refer to the current instance of the class.

```kaoscript
class Pet {
	private {
		@kind: PetKind
	}
	constructor(@kind)
	isCat(this: Pet) => @kind == PetKind.Cat
	// an error will be thrown
}
```

## accessbility

|                                | `Private` | `Internal` | `Protected` | `Public` |
| ------------------------------ | :-------: | :--------: | :---------: | :------: |
| Same class                     |    ✅     |     ✅     |     ✅      |    ✅    |
| Same package subclass          |    ❌     |     ✅     |     ✅      |    ✅    |
| Same package non-subclass      |    ❌     |     ✅     |     ❌      |    ✅    |
| Different package subclass     |    ❌     |     ❌     |     ✅      |    ✅    |
| Different package non-subclass |    ❌     |     ❌     |     ❌      |    ✅    |

### Inheritance

Unlike C++, kaoscript supports only public inheritance because:
- restrictive (private or protected) inheritance won't allow a subclass to validate the contract of the superclass.

## versioning

kaoscript classes can be signed with a version which could be used for serialization.

```kaoscript
class Rectangle@1.0.0 {
    private {
        @color: String
    }

    constructor(@color = 'black')

    draw(canvas) {
        return `I'm drawing a \(@color) rectangle.`
    }
}

console.log(Rectangle.name)
// Rectangle
console.log(Rectangle.version)
// 1.0.0
```

## sealed

`sealed` classes won't be modified by any `impl` statements.

```kaoscript
sealed class Shape {
	private {
		@color: String
	}
	constructor(@color)
}

impl Shape {
	draw(shape): String {
		return `I'm drawing a \(@color) \(shape).`
	}
}
```

## syntax

```syntax
[sealed] [abstract] class *varname*["<" *generic-type* ">"][@ *version*] [extends *varname*] [implements *varname1* ... [, *varnameN*]] {
	(
		[private | internal | protected | public] (
			[static] final late (
				{
					([@]*varname*[: *type*] [= *value*])+
				}
				|
				[@]*varname*[: *type*]
			)
			|
			[static] late (
				{
					([final] [@]*varname*[: *type*] [= *value*])+
				}
				|
				[@]*varname*[: *type*]
			)
			|
			static final (
				{
					(
						late [@]*varname*[: *type*] [= *value*]
						|
						[@]*varname*[: *type*] = *value*
						|
						*property*
						|
						*method*
					)+
				}
				|
				[@]*varname*[: *type*] = *value*
				|
				*property*
				|
				*method*
			)
			|
			static (
				{
					(
						[final] late [@]*varname*[: *type*] [= *value*]
						|
						final [@]*varname*[: *type*] = *value*
						|
						[@]*varname*[: *type*] [= *value*]
						|
						*property*
						|
						*method*
						|
						*alias*
					)+
				}
				|
				[@]*varname*[: *type*] [= *value*]
				|
				*property*
				|
				*method*
				|
				*alias*
			)
			|
			final (
				{
					(
						late [@]*varname*[: *type*] [= *value*]
						|
						[@]*varname*[: *type*] = *value*
						|
						[override] *property*
						|
						[override] *method*
					)+
				}
				|
				[@]*varname*[: *type*] = *value*
				|
				*property*
				|
				*method*
			)
			|
			(abstract | [final] override) (
				{
					(
						*property*
						|
						*method*
					)+
				}
				|
				*property*
				|
				*method*
			)
			|
			[final] assist (
				{
					(*method*)+
				}
				|
				*method*
			)
			|
			[static] proxy {
				(*varname* = @*expression*)+
			}
			|
			[static] proxy @*expression* {
				(*varname* [=> *varname*])+
			}
			|
			{
				(*variable* | *property* | *method* | *proxy*)+
			}
			|
			(*variable* | *property* | *method* | *proxy*)
		)
	)*
}

variable = (
	[@]*varname*([(: *type* | ?)] [= *value*])
	|
	final [@]*varname*[: *type*] = *value*
	|
	[final] late [@]*varname*[: *type*]
	|
	dyn [@]*varname* [= *value*]
	|
	override [@]*varname*: *type*
)

property = (
	[@]*varname*[: *type*] ({ get [, set] | set } | {
		(
			(get | set) [ | => *expression* | {
				*...statements*
			}]
		)+
	})
)

proxy = (proxy *varname* = @*expression*)

method = [async] *varname*([*parameter1* [, *parameter2* ... [, *parameterN*]])[: *type* | auto | this | @*varname*] [~ *class1* [, *class2* ... [, *classN*]]] [ => *expression* | {
	*...statements*
}]

parameter = [mut] (
	[(# | \* | ([\*] *varname* | \_) %)] [@]*varname* (
		! [: *param-type*] [?] (= | ??= | ##=) *expression*
		|
		[: *param-type*] [?] [(= | ??= | ##=) *expression*]
		|
		!?
	)
	|
	[[\*] *varname* | \_) %] _ (
		! [: *param-type*] [?] (= | ??= | ##=) *expression*
		|
		[: *param-type*] [?] [(= | ??= | ##=) *expression*]
	)
	|
	[[\*] *varname* | \_) %] *destructuring* (
		! [: *param-type*] [?] (= | ??= | ##=) *expression*
		|
		[: *param-type*] [?] [(= | ??= | ##=) *expression*]
	)
	|
	[(*varname* | \_) %] ...[{( [*min*], [*max*] | *quantity* )}][[@]*varname*] [: *param-type*] [?] [(= | ##=) *expression*]
)
```
