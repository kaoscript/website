---
name: Classes
menu: Guide
route: /guide/classes
---

# Classes

## syntax

```syntax
[abstract] class *varname*["<" *type* ">"][@ *version*] [extends *varname*] {
	(
		[private | internal | protected | public] (
			(abstract | override) *method*
			|
			(abstract | override) {
				*method*+
			}
			|
			(*variable* | *method*)
			|
			{
				(*variable* | *method*)+
			}
			|
			static (*static_variable* | *method*)
			|
			static {
				(*static_variable* | *method*)+
			}
			|
			lateinit {
				*lateinit_variable*+
			}
		)
	)*
}

variable = (
	auto [@]*varname* = *value*
	|
	const [@]*varname*[: *type*] = *value*
	|
	[@]*varname*[: *type*] [= *value*]
	|
	lateinit [const] [@]*varname*[: *type*]
)

static_variable = (
	auto [@]*varname* = *value*
	|
	const [@]*varname*[: *type*] = *value*
	|
	[@]*varname*[: *type*] [= *value*]
	|
	lateinit const [@]*varname*[: *type*]
)

lateinit_variable = (
	[const] [@]*varname*[: *type*] [= *value*]
	|
	auto [@]*varname* = *value*
)

method = [async] *varname*([[*parameter1*] [, [*parameter2*] ... [, [*parameterN*]]])[: *type* | auto | this | @*varname*] [~ *class1* [, *class2* ... [, *classN*]]] [ => *expression* | {
	*...statements*
}]
```

## example

```kaoscript
class Shape {
	private {
		_color: String
	}

	draw(): String {
		return `I'm drawing with a \(this._color) pen.`
	}
}
```

## class variable

A mutable variable must be initialized by a constructor unless it is a **static**, **nullable** and **lateinit** variable or it has a default value.

When no type is provided, the default type is `Any?`.

## this aliasing

`@x` is an alias for `this.x`, `this._x` or even `this.x()`.

```kaoscript
class Shape {
	private {
		@color: String
		// same as: _color: String
	}

	constructor(@color)
	// automatically set the instance variable '_color' as the parameter 'color'

	draw(): String {
		return `I'm drawing with a \(@color) pen.`
	}
}
```

## constructor

The constructor is called when creating a new object like `new Shape()`

```kaoscript
class Shape {
	private @color: String

	constructor() {
		@color = 'red'
	}
}
```

## destructor

The destructor is called by the statement `delete`.

```kaoscript
extern console

class Shape {
	private {
		@color: String
	}

	constructor(@color)

	destructor() {
		@color = null
	}
}

let s = new Shape('red')

delete s
// the destructor is called and the variable `s` is unreferenced
```

## static

The modifier `static` declares members that are not bound to class instances.

```kaoscript
class Shape {
	private {
		@color: String
		@type: String
	}
	static {
		const RED_CIRCLE = new Shape('circle', 'red')

		makeCircle(color: String): Shape => new Shape('circle', color)
		makeRectangle(color: String): Shape => new Shape('rectangle', color)
	}
	constructor(@type, @color)
}

const rb = Shape.makeRectangle('black')
const cr = Shape.RED_CIRCLE
```

## lateinit

The modifier `lateinit` allows an immutable variable (`const`) to be initialized in a constructor. To be precise, it needs to be initialized in a constructor.

Mutable variables won't require any initialization.
It's up to the developer to make sure that the variable is correctly initialized when needed.

```kaoscript
class Shape {
	public {
		lateinit const color: String
		lateinit const type: String
	}
	constructor(@type, @color)
}

const r = new Shape('rectangle', 'black')
console.log(r.color)
// black

r.color = 'yellow'
// throw a SyntaxException (immutable)
```

## method's return type

In addition to the standard return type, a method allows 2 new return types:

- a field with an alias (`@field`): return the field and the return type is the same as the field's type.
- the `this` expression: return the current instance `this` and the return type is of the current class.

```kaoscript
class Shape {
	private {
		@color: String
	}

	color1(): @color
	color1(@color): this

	color2(): String => @color
	color2(@color): Shape => this
}
```

`color1` and `color2` methods are identicals.

## superclass & subclass

```kaoscript
extern console

class Shape {
	private {
		_color: String
	}
	constructor(@color)
	destructor() {
		@color = null
	}
	color() => @color
	color(@color) => this
	draw(): String {
		return `I'm drawing with a \(@color) pen.`
	}
}

class Rectangle extends Shape {
	draw() {
		return `\(super()) I'm drawing a \(@color) rectangle.`
	}
}

let r = new Rectangle('black')

console.log(r.draw())
// I'm drawing with a black pen. I'm drawing a black rectangle.
```

## override

The `override` keyword indicates that the method must inherit a method from the superclass. If not, it will generate an error.

```kaoscript
class Shape {
	draw(): String {
		return `I'm drawing a shape.`
	}
}

class Rectangle extends Shape {
	override draw() {
		return `I'm drawing a rectangle.`
	}
}
```

If a parameter type, return type or error type is missing, it will be replaced but the type of the overridden type.
If the type isn't missing, it will need to be equal to the overridden type.

<!-- ## final

The `final` keyword indicates that the class or the method is final. It can't be extended or augmented.

```kaoscript
final class Shape {
	draw(): String {
		return `I'm drawing a shape.`
	}
}

class Rectangle extends Shape {
}
// will throw an error
``` -->

## abstract

```kaoscript
abstract class AbstractGreetings {
	private {
		_message: String: ''
	}

	constructor() {
		this('Hello!')
	}

	constructor(@message)

	abstract greet(name): String
}

class Greetings extends AbstractGreetings {
	greet(name) => `\(@message)\nIt's nice to meet you, \(name).`
}
```

## versioning

kaoscript classes can be signed with a version which could be used for serialization.

```kaoscript
class Rectangle@1.0.0 {
	private {
		_color: String
	}

	constructor(@color = 'black')

	draw(canvas) {
		return `I'm drawing a \(@color) rectangle.`
	}
}

console.log(Rectangle.name)
// Rectangle
console.log(Rectangle.version)
// 1.0.0
```